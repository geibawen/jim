var __DEV__=false;(function (global) {
  "use strict";

  global.__r = metroRequire;
  global.__d = define;
  global.__c = clear;
  global.__registerSegment = registerSegment;
  var modules = clear();
  var EMPTY = {};
  var _ref = {},
      hasOwnProperty = _ref.hasOwnProperty;

  if (__DEV__) {
    global.$RefreshReg$ = function () {};

    global.$RefreshSig$ = function () {
      return function (type) {
        return type;
      };
    };
  }

  function clear() {
    modules = Object.create(null);
    return modules;
  }

  if (__DEV__) {
    var verboseNamesToModuleIds = Object.create(null);
    var initializingModuleIds = [];
  }

  function define(factory, moduleId, dependencyMap) {
    if (modules[moduleId] != null) {
      if (__DEV__) {
        var inverseDependencies = arguments[4];

        if (inverseDependencies) {
          global.__accept(moduleId, factory, dependencyMap, inverseDependencies);
        }
      }

      return;
    }

    var mod = {
      dependencyMap: dependencyMap,
      factory: factory,
      hasError: false,
      importedAll: EMPTY,
      importedDefault: EMPTY,
      isInitialized: false,
      publicModule: {
        exports: {}
      }
    };
    modules[moduleId] = mod;

    if (__DEV__) {
      mod.hot = createHotReloadingObject();
      var verboseName = arguments[3];

      if (verboseName) {
        mod.verboseName = verboseName;
        verboseNamesToModuleIds[verboseName] = moduleId;
      }
    }
  }

  function metroRequire(moduleId) {
    if (__DEV__ && typeof moduleId === "string") {
      var verboseName = moduleId;
      moduleId = verboseNamesToModuleIds[verboseName];

      if (moduleId == null) {
        throw new Error("Unknown named module: \"" + verboseName + "\"");
      } else {
        console.warn("Requiring module \"" + verboseName + "\" by name is only supported for " + "debugging purposes and will BREAK IN PRODUCTION!");
      }
    }

    var moduleIdReallyIsNumber = moduleId;

    if (__DEV__) {
      var initializingIndex = initializingModuleIds.indexOf(moduleIdReallyIsNumber);

      if (initializingIndex !== -1) {
        var cycle = initializingModuleIds.slice(initializingIndex).map(function (id) {
          return modules[id] ? modules[id].verboseName : "[unknown]";
        });
        cycle.push(cycle[0]);
        console.warn("Require cycle: " + cycle.join(" -> ") + "\n\n" + "Require cycles are allowed, but can result in uninitialized values. " + "Consider refactoring to remove the need for a cycle.");
      }
    }

    var module = modules[moduleIdReallyIsNumber];
    return module && module.isInitialized ? module.publicModule.exports : guardedLoadModule(moduleIdReallyIsNumber, module);
  }

  function metroImportDefault(moduleId) {
    if (__DEV__ && typeof moduleId === "string") {
      var verboseName = moduleId;
      moduleId = verboseNamesToModuleIds[verboseName];
    }

    var moduleIdReallyIsNumber = moduleId;

    if (modules[moduleIdReallyIsNumber] && modules[moduleIdReallyIsNumber].importedDefault !== EMPTY) {
      return modules[moduleIdReallyIsNumber].importedDefault;
    }

    var exports = metroRequire(moduleIdReallyIsNumber);
    var importedDefault = exports && exports.__esModule ? exports.default : exports;
    return modules[moduleIdReallyIsNumber].importedDefault = importedDefault;
  }

  metroRequire.importDefault = metroImportDefault;

  function metroImportAll(moduleId) {
    if (__DEV__ && typeof moduleId === "string") {
      var verboseName = moduleId;
      moduleId = verboseNamesToModuleIds[verboseName];
    }

    var moduleIdReallyIsNumber = moduleId;

    if (modules[moduleIdReallyIsNumber] && modules[moduleIdReallyIsNumber].importedAll !== EMPTY) {
      return modules[moduleIdReallyIsNumber].importedAll;
    }

    var exports = metroRequire(moduleIdReallyIsNumber);
    var importedAll;

    if (exports && exports.__esModule) {
      importedAll = exports;
    } else {
      importedAll = {};

      if (exports) {
        for (var key in exports) {
          if (hasOwnProperty.call(exports, key)) {
            importedAll[key] = exports[key];
          }
        }
      }

      importedAll.default = exports;
    }

    return modules[moduleIdReallyIsNumber].importedAll = importedAll;
  }

  metroRequire.importAll = metroImportAll;
  var inGuard = false;

  function guardedLoadModule(moduleId, module) {
    if (!inGuard && global.ErrorUtils) {
      inGuard = true;
      var returnValue;

      try {
        returnValue = loadModuleImplementation(moduleId, module);
      } catch (e) {
        global.ErrorUtils.reportFatalError(e);
      }

      inGuard = false;
      return returnValue;
    } else {
      return loadModuleImplementation(moduleId, module);
    }
  }

  var ID_MASK_SHIFT = 16;
  var LOCAL_ID_MASK = ~0 >>> ID_MASK_SHIFT;

  function unpackModuleId(moduleId) {
    var segmentId = moduleId >>> ID_MASK_SHIFT;
    var localId = moduleId & LOCAL_ID_MASK;
    return {
      segmentId: segmentId,
      localId: localId
    };
  }

  metroRequire.unpackModuleId = unpackModuleId;

  function packModuleId(value) {
    return (value.segmentId << ID_MASK_SHIFT) + value.localId;
  }

  metroRequire.packModuleId = packModuleId;
  var moduleDefinersBySegmentID = [];

  function registerSegment(segmentID, moduleDefiner) {
    moduleDefinersBySegmentID[segmentID] = moduleDefiner;
  }

  function loadModuleImplementation(moduleId, module) {
    if (!module && moduleDefinersBySegmentID.length > 0) {
      var _unpackModuleId = unpackModuleId(moduleId),
          segmentId = _unpackModuleId.segmentId,
          localId = _unpackModuleId.localId;

      var definer = moduleDefinersBySegmentID[segmentId];

      if (definer != null) {
        definer(localId);
        module = modules[moduleId];
      }
    }

    var nativeRequire = global.nativeRequire;

    if (!module && nativeRequire) {
      var _unpackModuleId2 = unpackModuleId(moduleId),
          _segmentId = _unpackModuleId2.segmentId,
          _localId = _unpackModuleId2.localId;

      nativeRequire(_localId, _segmentId);
      module = modules[moduleId];
    }

    if (!module) {
      throw unknownModuleError(moduleId);
    }

    if (module.hasError) {
      throw moduleThrewError(moduleId, module.error);
    }

    if (__DEV__) {
      var Systrace = metroRequire.Systrace,
          Refresh = metroRequire.Refresh;
    }

    module.isInitialized = true;
    var _module = module,
        factory = _module.factory,
        dependencyMap = _module.dependencyMap;

    if (__DEV__) {
      initializingModuleIds.push(moduleId);
    }

    try {
      if (__DEV__) {
        Systrace.beginEvent("JS_require_" + (module.verboseName || moduleId));
      }

      var moduleObject = module.publicModule;

      if (__DEV__) {
        moduleObject.hot = module.hot;
        var prevRefreshReg = global.$RefreshReg$;
        var prevRefreshSig = global.$RefreshSig$;

        if (Refresh != null) {
          var RefreshRuntime = Refresh;

          global.$RefreshReg$ = function (type, id) {
            RefreshRuntime.register(type, moduleId + " " + id);
          };

          global.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;
        }
      }

      moduleObject.id = moduleId;
      factory(global, metroRequire, metroImportDefault, metroImportAll, moduleObject, moduleObject.exports, dependencyMap);

      if (!__DEV__) {
        module.factory = undefined;
        module.dependencyMap = undefined;
      }

      if (__DEV__) {
        Systrace.endEvent();

        if (Refresh != null) {
          registerExportsForReactRefresh(Refresh, moduleObject.exports, moduleId);
        }
      }

      return moduleObject.exports;
    } catch (e) {
      module.hasError = true;
      module.error = e;
      module.isInitialized = false;
      module.publicModule.exports = undefined;
      throw e;
    } finally {
      if (__DEV__) {
        if (initializingModuleIds.pop() !== moduleId) {
          throw new Error("initializingModuleIds is corrupt; something is terribly wrong");
        }

        global.$RefreshReg$ = prevRefreshReg;
        global.$RefreshSig$ = prevRefreshSig;
      }
    }
  }

  function unknownModuleError(id) {
    var message = 'Requiring unknown module "' + id + '".';

    if (__DEV__) {
      message += " If you are sure the module exists, try restarting Metro. " + "You may also want to run `yarn` or `npm install`.";
    }

    return Error(message);
  }

  function moduleThrewError(id, error) {
    var displayName = __DEV__ && modules[id] && modules[id].verboseName || id;
    return Error('Requiring module "' + displayName + '", which threw an exception: ' + error);
  }

  if (__DEV__) {
    metroRequire.Systrace = {
      beginEvent: function beginEvent() {},
      endEvent: function endEvent() {}
    };

    metroRequire.getModules = function () {
      return modules;
    };

    var createHotReloadingObject = function createHotReloadingObject() {
      var hot = {
        _acceptCallback: null,
        _disposeCallback: null,
        _didAccept: false,
        accept: function accept(callback) {
          hot._didAccept = true;
          hot._acceptCallback = callback;
        },
        dispose: function dispose(callback) {
          hot._disposeCallback = callback;
        }
      };
      return hot;
    };

    var reactRefreshTimeout = null;

    var metroHotUpdateModule = function metroHotUpdateModule(id, factory, dependencyMap, inverseDependencies) {
      var mod = modules[id];

      if (!mod) {
        if (factory) {
          return;
        }

        throw unknownModuleError(id);
      }

      if (!mod.hasError && !mod.isInitialized) {
        mod.factory = factory;
        mod.dependencyMap = dependencyMap;
        return;
      }

      var Refresh = metroRequire.Refresh;
      var pendingModuleIDs = [id];
      var updatedModuleIDs = [];
      var seenModuleIDs = new Set();
      var refreshBoundaryIDs = new Set();

      while (pendingModuleIDs.length > 0) {
        var pendingID = pendingModuleIDs.pop();

        if (seenModuleIDs.has(pendingID)) {
          continue;
        }

        seenModuleIDs.add(pendingID);
        var pendingModule = modules[pendingID];

        if (pendingModule != null) {
          var pendingHot = pendingModule.hot;

          if (pendingHot == null) {
            throw new Error("[Refresh] Expected module.hot to always exist in DEV.");
          }

          var canAccept = pendingHot._didAccept;

          if (!canAccept && Refresh != null) {
            var isBoundary = isReactRefreshBoundary(Refresh, pendingModule.publicModule.exports);

            if (isBoundary) {
              canAccept = true;
              refreshBoundaryIDs.add(pendingID);
            }
          }

          if (canAccept) {
            updatedModuleIDs.push(pendingID);
            continue;
          }
        }

        var parentIDs = inverseDependencies[pendingID];

        if (parentIDs.length === 0) {
          performFullRefresh();
          return;
        }

        updatedModuleIDs.push(pendingID);
        parentIDs.forEach(function (parentID) {
          return pendingModuleIDs.push(parentID);
        });
      }

      seenModuleIDs.clear();

      for (var i = 0; i < updatedModuleIDs.length; i++) {
        var updatedID = updatedModuleIDs[i];

        if (seenModuleIDs.has(updatedID)) {
          continue;
        }

        seenModuleIDs.add(updatedID);
        var _mod = modules[updatedID];

        if (_mod == null) {
          throw new Error("[Refresh] Expected to find the updated module.");
        }

        var prevExports = _mod.publicModule.exports;
        var didError = runUpdatedModule(updatedID, updatedID === id ? factory : undefined, updatedID === id ? dependencyMap : undefined);
        var nextExports = _mod.publicModule.exports;

        if (didError) {
          return;
        }

        if (refreshBoundaryIDs.has(updatedID)) {
          var isNoLongerABoundary = !isReactRefreshBoundary(Refresh, nextExports);
          var didInvalidate = shouldInvalidateReactRefreshBoundary(Refresh, prevExports, nextExports);

          if (isNoLongerABoundary || didInvalidate) {
            var _parentIDs = inverseDependencies[updatedID];

            if (_parentIDs.length === 0) {
              performFullRefresh();
              return;
            }

            for (var j = 0; j < _parentIDs.length; j++) {
              var parentID = _parentIDs[j];
              var parentMod = modules[parentID];

              if (parentMod == null) {
                throw new Error("[Refresh] Expected to find parent module.");
              }

              var canAcceptParent = isReactRefreshBoundary(Refresh, parentMod.publicModule.exports);

              if (canAcceptParent) {
                refreshBoundaryIDs.add(parentID);
                updatedModuleIDs.push(parentID);
              } else {
                performFullRefresh();
                return;
              }
            }
          }
        }
      }

      if (Refresh != null) {
        if (reactRefreshTimeout == null) {
          reactRefreshTimeout = setTimeout(function () {
            reactRefreshTimeout = null;
            Refresh.performReactRefresh();
          }, 30);
        }
      }
    };

    var runUpdatedModule = function runUpdatedModule(id, factory, dependencyMap) {
      var mod = modules[id];

      if (mod == null) {
        throw new Error("[Refresh] Expected to find the module.");
      }

      var hot = mod.hot;

      if (!hot) {
        throw new Error("[Refresh] Expected module.hot to always exist in DEV.");
      }

      if (hot._disposeCallback) {
        try {
          hot._disposeCallback();
        } catch (error) {
          console.error("Error while calling dispose handler for module " + id + ": ", error);
        }
      }

      if (factory) {
        mod.factory = factory;
      }

      if (dependencyMap) {
        mod.dependencyMap = dependencyMap;
      }

      mod.hasError = false;
      mod.error = undefined;
      mod.importedAll = EMPTY;
      mod.importedDefault = EMPTY;
      mod.isInitialized = false;
      var prevExports = mod.publicModule.exports;
      mod.publicModule.exports = {};
      hot._didAccept = false;
      hot._acceptCallback = null;
      hot._disposeCallback = null;
      metroRequire(id);

      if (mod.hasError) {
        mod.hasError = false;
        mod.isInitialized = true;
        mod.error = null;
        mod.publicModule.exports = prevExports;
        return true;
      }

      if (hot._acceptCallback) {
        try {
          hot._acceptCallback();
        } catch (error) {
          console.error("Error while calling accept handler for module " + id + ": ", error);
        }
      }

      return false;
    };

    var performFullRefresh = function performFullRefresh() {
      if (typeof window !== "undefined" && window.location != null && typeof window.location.reload === "function") {
        window.location.reload();
      } else {
        var Refresh = metroRequire.Refresh;

        if (Refresh != null) {
          Refresh.performFullRefresh();
        } else {
          console.warn("Could not reload the application after an edit.");
        }
      }
    };

    var isReactRefreshBoundary = function isReactRefreshBoundary(Refresh, moduleExports) {
      if (Refresh.isLikelyComponentType(moduleExports)) {
        return true;
      }

      if (moduleExports == null || typeof moduleExports !== "object") {
        return false;
      }

      var hasExports = false;
      var areAllExportsComponents = true;

      for (var key in moduleExports) {
        hasExports = true;

        if (key === "__esModule") {
          continue;
        }

        var desc = Object.getOwnPropertyDescriptor(moduleExports, key);

        if (desc && desc.get) {
          return false;
        }

        var exportValue = moduleExports[key];

        if (!Refresh.isLikelyComponentType(exportValue)) {
          areAllExportsComponents = false;
        }
      }

      return hasExports && areAllExportsComponents;
    };

    var shouldInvalidateReactRefreshBoundary = function shouldInvalidateReactRefreshBoundary(Refresh, prevExports, nextExports) {
      var prevSignature = getRefreshBoundarySignature(Refresh, prevExports);
      var nextSignature = getRefreshBoundarySignature(Refresh, nextExports);

      if (prevSignature.length !== nextSignature.length) {
        return true;
      }

      for (var i = 0; i < nextSignature.length; i++) {
        if (prevSignature[i] !== nextSignature[i]) {
          return true;
        }
      }

      return false;
    };

    var getRefreshBoundarySignature = function getRefreshBoundarySignature(Refresh, moduleExports) {
      var signature = [];
      signature.push(Refresh.getFamilyByType(moduleExports));

      if (moduleExports == null || typeof moduleExports !== "object") {
        return signature;
      }

      for (var key in moduleExports) {
        if (key === "__esModule") {
          continue;
        }

        var desc = Object.getOwnPropertyDescriptor(moduleExports, key);

        if (desc && desc.get) {
          continue;
        }

        var exportValue = moduleExports[key];
        signature.push(key);
        signature.push(Refresh.getFamilyByType(exportValue));
      }

      return signature;
    };

    var registerExportsForReactRefresh = function registerExportsForReactRefresh(Refresh, moduleExports, moduleID) {
      Refresh.register(moduleExports, moduleID + " %exports%");

      if (moduleExports == null || typeof moduleExports !== "object") {
        return;
      }

      for (var key in moduleExports) {
        var desc = Object.getOwnPropertyDescriptor(moduleExports, key);

        if (desc && desc.get) {
          continue;
        }

        var exportValue = moduleExports[key];
        var typeID = moduleID + " %exports% " + key;
        Refresh.register(exportValue, typeID);
      }
    };

    global.__accept = metroHotUpdateModule;
  }
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
(function (global) {
  var inspect = function () {
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        formatValueCalls: 0,
        stylize: stylizeNoColor
      };
      return formatValue(ctx, obj, opts.depth);
    }

    function stylizeNoColor(str, styleType) {
      return str;
    }

    function arrayToHash(array) {
      var hash = {};
      array.forEach(function (val, idx) {
        hash[val] = true;
      });
      return hash;
    }

    function formatValue(ctx, value, recurseTimes) {
      ctx.formatValueCalls++;

      if (ctx.formatValueCalls > 200) {
        return "[TOO BIG formatValueCalls " + ctx.formatValueCalls + " exceeded limit of 200]";
      }

      var primitive = formatPrimitive(ctx, value);

      if (primitive) {
        return primitive;
      }

      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);

      if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }

      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }

        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }

        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }

        if (isError(value)) {
          return formatError(value);
        }
      }

      var base = '',
          array = false,
          braces = ['{', '}'];

      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      }

      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }

      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }

      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }

      if (isError(value)) {
        base = ' ' + formatError(value);
      }

      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }

      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }

      ctx.seen.push(value);
      var output;

      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function (key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }

      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }

    function formatPrimitive(ctx, value) {
      if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, 'string');
      }

      if (isNumber(value)) return ctx.stylize('' + value, 'number');
      if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
      if (isNull(value)) return ctx.stylize('null', 'null');
    }

    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }

    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];

      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push('');
        }
      }

      keys.forEach(function (key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }

    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key]
      };

      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }

      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }

      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }

          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function (line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function (line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }

      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }

        name = JSON.stringify('' + key);

        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    }

    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function (prev, cur) {
        numLinesEst++;
        if (cur.indexOf('\n') >= 0) numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);

      if (length > 60) {
        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
      }

      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    function isArray(ar) {
      return Array.isArray(ar);
    }

    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }

    function isNull(arg) {
      return arg === null;
    }

    function isNullOrUndefined(arg) {
      return arg == null;
    }

    function isNumber(arg) {
      return typeof arg === 'number';
    }

    function isString(arg) {
      return typeof arg === 'string';
    }

    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }

    function isUndefined(arg) {
      return arg === void 0;
    }

    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }

    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }

    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }

    function isError(e) {
      return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
    }

    function isFunction(arg) {
      return typeof arg === 'function';
    }

    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }

    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    return inspect;
  }();

  var OBJECT_COLUMN_NAME = '(index)';
  var LOG_LEVELS = {
    trace: 0,
    info: 1,
    warn: 2,
    error: 3
  };
  var INSPECTOR_LEVELS = [];
  INSPECTOR_LEVELS[LOG_LEVELS.trace] = 'debug';
  INSPECTOR_LEVELS[LOG_LEVELS.info] = 'log';
  INSPECTOR_LEVELS[LOG_LEVELS.warn] = 'warning';
  INSPECTOR_LEVELS[LOG_LEVELS.error] = 'error';
  var INSPECTOR_FRAMES_TO_SKIP = __DEV__ ? 2 : 1;

  function getNativeLogFunction(level) {
    return function () {
      var str;

      if (arguments.length === 1 && typeof arguments[0] === 'string') {
        str = arguments[0];
      } else {
        str = Array.prototype.map.call(arguments, function (arg) {
          return inspect(arg, {
            depth: 10
          });
        }).join(', ');
      }

      var logLevel = level;

      if (str.slice(0, 9) === 'Warning: ' && logLevel >= LOG_LEVELS.error) {
        logLevel = LOG_LEVELS.warn;
      }

      if (global.__inspectorLog) {
        global.__inspectorLog(INSPECTOR_LEVELS[logLevel], str, [].slice.call(arguments), INSPECTOR_FRAMES_TO_SKIP);
      }

      if (groupStack.length) {
        str = groupFormat('', str);
      }

      global.nativeLoggingHook(str, logLevel);
    };
  }

  function repeat(element, n) {
    return Array.apply(null, Array(n)).map(function () {
      return element;
    });
  }

  function consoleTablePolyfill(rows) {
    if (!Array.isArray(rows)) {
      var data = rows;
      rows = [];

      for (var key in data) {
        if (data.hasOwnProperty(key)) {
          var row = data[key];
          row[OBJECT_COLUMN_NAME] = key;
          rows.push(row);
        }
      }
    }

    if (rows.length === 0) {
      global.nativeLoggingHook('', LOG_LEVELS.info);
      return;
    }

    var columns = Object.keys(rows[0]).sort();
    var stringRows = [];
    var columnWidths = [];
    columns.forEach(function (k, i) {
      columnWidths[i] = k.length;

      for (var j = 0; j < rows.length; j++) {
        var cellStr = (rows[j][k] || '?').toString();
        stringRows[j] = stringRows[j] || [];
        stringRows[j][i] = cellStr;
        columnWidths[i] = Math.max(columnWidths[i], cellStr.length);
      }
    });

    function joinRow(row, space) {
      var cells = row.map(function (cell, i) {
        var extraSpaces = repeat(' ', columnWidths[i] - cell.length).join('');
        return cell + extraSpaces;
      });
      space = space || ' ';
      return cells.join(space + '|' + space);
    }

    var separators = columnWidths.map(function (columnWidth) {
      return repeat('-', columnWidth).join('');
    });
    var separatorRow = joinRow(separators, '-');
    var header = joinRow(columns);
    var table = [header, separatorRow];

    for (var i = 0; i < rows.length; i++) {
      table.push(joinRow(stringRows[i]));
    }

    global.nativeLoggingHook('\n' + table.join('\n'), LOG_LEVELS.info);
  }

  var GROUP_PAD = "\u2502";
  var GROUP_OPEN = "\u2510";
  var GROUP_CLOSE = "\u2518";
  var groupStack = [];

  function groupFormat(prefix, msg) {
    return groupStack.join('') + prefix + ' ' + (msg || '');
  }

  function consoleGroupPolyfill(label) {
    global.nativeLoggingHook(groupFormat(GROUP_OPEN, label), LOG_LEVELS.info);
    groupStack.push(GROUP_PAD);
  }

  function consoleGroupCollapsedPolyfill(label) {
    global.nativeLoggingHook(groupFormat(GROUP_CLOSE, label), LOG_LEVELS.info);
    groupStack.push(GROUP_PAD);
  }

  function consoleGroupEndPolyfill() {
    groupStack.pop();
    global.nativeLoggingHook(groupFormat(GROUP_CLOSE), LOG_LEVELS.info);
  }

  function consoleAssertPolyfill(expression, label) {
    if (!expression) {
      global.nativeLoggingHook('Assertion failed: ' + label, LOG_LEVELS.error);
    }
  }

  if (global.nativeLoggingHook) {
    var originalConsole = global.console;

    if (__DEV__ && originalConsole) {
      var descriptor = Object.getOwnPropertyDescriptor(global, 'console');

      if (descriptor) {
        Object.defineProperty(global, 'originalConsole', descriptor);
      }
    }

    global.console = {
      error: getNativeLogFunction(LOG_LEVELS.error),
      info: getNativeLogFunction(LOG_LEVELS.info),
      log: getNativeLogFunction(LOG_LEVELS.info),
      warn: getNativeLogFunction(LOG_LEVELS.warn),
      trace: getNativeLogFunction(LOG_LEVELS.trace),
      debug: getNativeLogFunction(LOG_LEVELS.trace),
      table: consoleTablePolyfill,
      group: consoleGroupPolyfill,
      groupEnd: consoleGroupEndPolyfill,
      groupCollapsed: consoleGroupCollapsedPolyfill,
      assert: consoleAssertPolyfill
    };
    Object.defineProperty(console, '_isPolyfilled', {
      value: true,
      enumerable: false
    });

    if (__DEV__ && originalConsole) {
      Object.keys(console).forEach(function (methodName) {
        var reactNativeMethod = console[methodName];

        if (originalConsole[methodName]) {
          console[methodName] = function () {
            if (methodName === 'assert') {
              if (!arguments[0]) {
                originalConsole.assert.apply(originalConsole, arguments);
              }
            } else {
              originalConsole[methodName].apply(originalConsole, arguments);
            }

            reactNativeMethod.apply(console, arguments);
          };
        }
      });
      ['clear', 'dir', 'dirxml', 'groupCollapsed', 'profile', 'profileEnd'].forEach(function (methodName) {
        if (typeof originalConsole[methodName] === 'function') {
          console[methodName] = function () {
            originalConsole[methodName].apply(originalConsole, arguments);
          };
        }
      });
    }
  } else if (!global.console) {
    var log = global.print || function consoleLoggingStub() {};

    global.console = {
      error: log,
      info: log,
      log: log,
      warn: log,
      trace: log,
      debug: log,
      table: log
    };
    Object.defineProperty(console, '_isPolyfilled', {
      value: true,
      enumerable: false
    });
  }
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
(function (global) {
  var _inGuard = 0;

  var _globalHandler = function onError(e, isFatal) {
    throw e;
  };

  var ErrorUtils = {
    setGlobalHandler: function setGlobalHandler(fun) {
      _globalHandler = fun;
    },
    getGlobalHandler: function getGlobalHandler() {
      return _globalHandler;
    },
    reportError: function reportError(error) {
      _globalHandler && _globalHandler(error, false);
    },
    reportFatalError: function reportFatalError(error) {
      _globalHandler && _globalHandler(error, true);
    },
    applyWithGuard: function applyWithGuard(fun, context, args, unused_onError, unused_name) {
      try {
        _inGuard++;
        return fun.apply(context, args);
      } catch (e) {
        ErrorUtils.reportError(e);
      } finally {
        _inGuard--;
      }

      return null;
    },
    applyWithGuardIfNeeded: function applyWithGuardIfNeeded(fun, context, args) {
      if (ErrorUtils.inGuard()) {
        return fun.apply(context, args);
      } else {
        ErrorUtils.applyWithGuard(fun, context, args);
      }

      return null;
    },
    inGuard: function inGuard() {
      return !!_inGuard;
    },
    guard: function guard(fun, name, context) {
      var _ref;

      if (typeof fun !== 'function') {
        console.warn('A function must be passed to ErrorUtils.guard, got ', fun);
        return null;
      }

      var guardName = (_ref = name != null ? name : fun.name) != null ? _ref : '<generated guard>';

      function guarded() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return ErrorUtils.applyWithGuard(fun, context != null ? context : this, args, null, guardName);
      }

      return guarded;
    }
  };
  global.ErrorUtils = ErrorUtils;
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
(function (global) {
  (function () {
    'use strict';

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    if (typeof Object.entries !== 'function') {
      Object.entries = function (object) {
        if (object == null) {
          throw new TypeError('Object.entries called on non-object');
        }

        var entries = [];

        for (var key in object) {
          if (hasOwnProperty.call(object, key)) {
            entries.push([key, object[key]]);
          }
        }

        return entries;
      };
    }

    if (typeof Object.values !== 'function') {
      Object.values = function (object) {
        if (object == null) {
          throw new TypeError('Object.values called on non-object');
        }

        var values = [];

        for (var key in object) {
          if (hasOwnProperty.call(object, key)) {
            values.push(object[key]);
          }
        }

        return values;
      };
    }
  })();
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.parse = parse;

  var _require = _$$_REQUIRE(_dependencyMap[0], "../Parser/MapParserPng"),
      parseSync = _require.parseSync;

  var Base64 = _$$_REQUIRE(_dependencyMap[1], "base64-js");

  function parse(array) {
    if (false) {
      var data = NativeBase64.toByteArray(array);
      return parseSync(data);
    }

    var data = Base64.toByteArray(array);
    return parseSync(data);
  }
},0,[1,21],"projects/com.roborock.tanos/Parser/index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.parseSync = parseSync;
  exports.parse = parse;
  exports.getSequence = getSequence;
  exports.convertMap = convertMap;
  exports.convertCarpetMap = convertCarpetMap;

  var _defineProperty2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/defineProperty"));

  var _slicedToArray2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/slicedToArray"));

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/extends"));

  var _Palette = _$$_REQUIRE(_dependencyMap[4], "../Common/Palette.js");

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"](); return it.next.bind(it); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  var _require = _$$_REQUIRE(_dependencyMap[5], "../Utils/Converter"),
      BytesToInt = _require.BytesToInt,
      fill = _require.fill,
      BytesToASCII = _require.BytesToASCII;

  var _require2 = _$$_REQUIRE(_dependencyMap[6], "./png/png"),
      getIndexPngBase64 = _require2.getIndexPngBase64;

  var Scale = 10;
  var Prefix = {
    type: 2,
    header: 2,
    payload: 4
  };
  var MaxBlockNum = 32;
  var Schema = {
    0x7272: {
      header: [['major', 2], ['minor', 2], ['index', 4], ['sequence', 4], ['resolution', 2]]
    },
    10008: {
      type: 'robot',
      header: [],
      payload: function payload(result, data) {
        var pos = {
          x: BytesToInt(data.data, data.offset, 4) / Scale,
          y: BytesToInt(data.data, data.offset + 4, 4) / Scale,
          angle: BytesToInt(data.data, data.offset + 8, 4)
        };
        if (typeof pos.x != 'undefined' && typeof pos.y != 'undefined') (0, _extends2.default)(result, pos);
      }
    },
    10002: {
      type: 'map',
      header: [['blockNum', 4], ['top', 4], ['left', 4], ['height', 4], ['width', 4]],
      payload: function payload(result, data) {
        return (0, _extends2.default)(result, data);
      }
    },
    10005: {
      type: 'staticPath',
      repeatable: true,
      header: [['num', 4], ['size', 4], ['pathId', 2], ['nameLength', 2]],
      payload: function payload(result, data) {
        var parsedNameString = '';
        var nameBytes = [];

        for (var i = 0; i < result.nameLength; i++) {
          nameBytes.push(data.data[data.offset + i]);
        }

        parsedNameString = decodeUtf8(nameBytes);
        result.name = parsedNameString;
        result.points = new Array((data.length - result.nameLength) / result.size);

        for (var _i = 0; _i < result.points.length; ++_i) {
          var offset = data.offset + result.nameLength + _i * result.size;
          result.points[_i] = {
            x: BytesToInt(data.data, offset, 4) / Scale,
            y: BytesToInt(data.data, offset + 4, 4) / Scale
          };
        }
      }
    },
    10010: {
      type: 'walls',
      repeatable: true,
      header: [['num', 4], ['size', 4]],
      payload: function payload(result, data) {
        result.points = new Array(data.length / result.size);

        for (var i = 0; i < result.points.length; ++i) {
          var offset = data.offset + i * result.size;
          result.points[i] = {
            x: BytesToInt(data.data, offset, 4) / Scale,
            y: BytesToInt(data.data, offset + 4, 4) / Scale
          };
        }
      }
    },
    10009: {
      type: 'fbzs',
      header: [['num', 4]],
      payload: function payload(result, data) {
        result.fbzs = new Array(result.num);

        for (var i = 0; i < result.num; ++i) {
          var offset = data.offset + i * 32;
          result.fbzs[i] = [BytesToInt(data.data, offset, 4) / Scale, BytesToInt(data.data, offset + 4, 4) / Scale, BytesToInt(data.data, offset + 8, 4) / Scale, BytesToInt(data.data, offset + 12, 4) / Scale, BytesToInt(data.data, offset + 16, 4) / Scale, BytesToInt(data.data, offset + 20, 4) / Scale, BytesToInt(data.data, offset + 24, 4) / Scale, BytesToInt(data.data, offset + 28, 4) / Scale];
        }
      }
    },
    10021: {
      type: 'speedBumps',
      header: [['num', 4]],
      payload: function payload(result, data) {
        result.speedBumps = new Array(result.num);

        for (var i = 0; i < result.num; ++i) {
          var offset = data.offset + i * 32;
          result.speedBumps[i] = [BytesToInt(data.data, offset, 4) / Scale, BytesToInt(data.data, offset + 4, 4) / Scale, BytesToInt(data.data, offset + 8, 4) / Scale, BytesToInt(data.data, offset + 12, 4) / Scale, BytesToInt(data.data, offset + 16, 4) / Scale, BytesToInt(data.data, offset + 20, 4) / Scale, BytesToInt(data.data, offset + 24, 4) / Scale, BytesToInt(data.data, offset + 28, 4) / Scale];
        }
      }
    },
    10020: {
      type: 'locatingAreas',
      header: [['num', 4]],
      payload: function payload(result, data) {
        result.speedBumps = new Array(result.num);

        for (var i = 0; i < result.num; ++i) {
          var offset = data.offset + i * 32;
          result.speedBumps[i] = [BytesToInt(data.data, offset, 4) / Scale, BytesToInt(data.data, offset + 4, 4) / Scale, BytesToInt(data.data, offset + 8, 4) / Scale, BytesToInt(data.data, offset + 12, 4) / Scale, BytesToInt(data.data, offset + 16, 4) / Scale, BytesToInt(data.data, offset + 20, 4) / Scale, BytesToInt(data.data, offset + 24, 4) / Scale, BytesToInt(data.data, offset + 28, 4) / Scale];
        }
      }
    },
    10004: {
      type: 'realPath',
      header: [['num', 4], ['size', 4]],
      payload: function payload(result, data) {
        result.points = new Array(data.length / result.size);

        for (var i = 0; i < result.points.length; ++i) {
          var offset = data.offset + i * result.size;
          result.points[i] = {
            x: BytesToInt(data.data, offset, 4) / Scale,
            y: BytesToInt(data.data, offset + 4, 4) / Scale
          };
        }
      }
    },
    10022: {
      type: 'plans',
      repeatable: true,
      header: [['num', 4], ['size', 4], ['planId', 2], ['nameLength', 2]],
      payload: function payload(result, data) {
        var parsedNameString = '';
        var nameBytes = [];

        for (var i = 0; i < result.nameLength; i++) {
          nameBytes.push(data.data[data.offset + i]);
        }

        parsedNameString = decodeUtf8(nameBytes);
        result.name = parsedNameString;
        result.ids = new Array((data.length - result.nameLength) / result.size);

        for (var _i2 = 0; _i2 < result.ids.length; ++_i2) {
          var offset = data.offset + result.nameLength + _i2 * result.size;
          result.ids[_i2] = BytesToInt(data.data, offset, result.size);
        }
      }
    },
    1024: {
      type: 'digest',
      header: []
    }
  };

  function decodeUtf8(bytes) {
    var encoded = "";

    for (var i = 0; i < bytes.length; i++) {
      encoded += '%' + bytes[i].toString(16);
    }

    return decodeURIComponent(encoded);
  }

  function parseSync(data) {
    if (!data || !data.length) return;
    var result = {};

    try {
      for (var offset = 0; offset < data.length; offset += parseContent(result, data, offset)) {
        ;
      }
    } catch (error) {
      console.log("TTTT parse - " + error + " data - " + JSON.stringify(data));
    }

    if (typeof result.carpetMap != 'undefined') result.carpetMap = convertCarpetMap(result.map, result.carpetMap);

    if (typeof result.map != 'undefined') {
      result.map = convertMap(result.map);
    }

    return result;
  }

  function parse(data, callback) {
    if (!data || !data.length || !callback) return;
    var result = {};

    try {
      for (var offset = 0; offset < data.length; offset += parseContent(result, data, offset)) {
        ;
      }
    } catch (error) {
      console.log("TTTT parse - " + error + " data - " + JSON.stringify(data));
    }

    callback(result);
  }

  function parseContent(result, data, offset) {
    var type = BytesToInt(data, offset, Prefix.type);
    var index = offset + Prefix.type;
    var length = {
      header: BytesToInt(data, index, Prefix.header),
      payload: BytesToInt(data, index + Prefix.header, Prefix.payload)
    };
    index += Prefix.header + Prefix.payload;
    offset += length.header;
    var schema = Schema[type];
    if (!schema) return length.header + length.payload;
    if (!schema.payload) return length.header + (schema.type && length.payload || 0);
    var obj = {};

    try {
      for (var _iterator = _createForOfIteratorHelperLoose(schema.header), _step; !(_step = _iterator()).done;) {
        var _ref = _step.value;

        var _ref2 = (0, _slicedToArray2.default)(_ref, 2);

        var name = _ref2[0];
        var len = _ref2[1];
        if (index >= offset) break;
        obj[name] = BytesToInt(data, index, len);
        index += len;
      }
    } catch (error) {
      console.log("AAAA - " + error + "  header - " + schema.header + " type - " + type);
    }

    schema.payload(obj, {
      data: data,
      offset: offset,
      length: length.payload
    });

    if (Object.keys(obj).length) {
      if (schema.repeatable) {
        if (result[schema.type]) {
          result[schema.type].push(obj);
        } else {
          result[schema.type] = [obj];
        }
      } else {
        result[schema.type] = obj;
      }
    }

    return length.header + length.payload;
  }

  function getSequence(data) {
    var offset = 0;
    var type = BytesToInt(data, offset, Prefix.type);
    var index = offset + Prefix.type;
    var length = {
      header: BytesToInt(data, index, Prefix.header),
      payload: BytesToInt(data, index + Prefix.header, Prefix.payload)
    };
    index += Prefix.header + Prefix.payload;
    offset += length.header;
    var schema = Schema[type];
    var obj = {};

    for (var _iterator2 = _createForOfIteratorHelperLoose(schema.header), _step2; !(_step2 = _iterator2()).done;) {
      var _ref3 = _step2.value;

      var _ref4 = (0, _slicedToArray2.default)(_ref3, 2);

      var name = _ref4[0];
      var len = _ref4[1];
      if (index >= offset) break;
      obj[name] = BytesToInt(data, index, len);
      index += len;
    }

    return obj;
  }

  function convertMap(map) {
    if (!map || !map.width || !map.height || !map.data || !map.data.length) {
      if (map.width && map.height && (!map.data || !map.data.length)) {
        return {
          isEmpty: true
        };
      }

      return {
        image: '',
        width: 100,
        height: 100,
        left: 512 - 50,
        top: 512 - 50,
        isEmpty: true
      };
    }

    var length = map.width * map.height;
    var rect = {};
    var mapPointNum = 0;
    rect.left = 0;
    rect.top = 0;
    rect.height = map.height;
    rect.width = map.width;

    var colorBytes = function colorBytes(color) {
      return color;
    };

    var palette = {
      obstacles: 3,
      space: 4
    };
    var debugList = [];

    for (var i = 0; i < MaxBlockNum; i++) {
      debugList.push(0);
    }

    var headerBmp = 14;
    var headerDib = 108;
    var header = headerBmp + headerDib;
    var data = new Array((rect.width + 1) * rect.height);
    fill(data, 0);
    var mapListData = new Object();
    var mapList = new Object();
    var blockNum = map.blockNum;
    var emptyData = data.concat();
    var dataBlockMap = data.concat();
    var dataBCBackgroundMap = data.concat();
    var pointsCount = new Array(MaxBlockNum);
    fill(pointsCount, 0);
    var colorData = new Array(MaxBlockNum);
    fill(colorData, 0);
    var mapIDleft = 1024,
        mapIDup = 1024,
        mapIDdown = 0,
        mapIDright = 0;
    var centerInfo = [];

    for (var _i3 = 0; _i3 < MaxBlockNum; _i3++) {
      var singleItem = {
        x: 0,
        y: 0,
        count: 0,
        minX: rect.width,
        maxX: 0
      };
      centerInfo.push(singleItem);
    }

    var neighbourInfo = new Array(MaxBlockNum * MaxBlockNum);
    fill(neighbourInfo, 0);
    var tempBlockInfo = [];

    for (var row = 0; row < rect.height; ++row) {
      var offset = map.offset + (row + rect.top) * map.width;

      for (var col = 0; col < rect.width; ++col) {
        var pixel = map.data[offset + col + rect.left];

        if ((pixel & 0x07) == 0) {
          tempBlockInfo.push(0);
          continue;
        }

        var mapID = pixel >>> 3;
        tempBlockInfo.push(mapID);
        if (mapID == 0) continue;
        neighbourInfo[MaxBlockNum * mapID + mapID] = 1;

        if (row != 0) {
          var upID = tempBlockInfo[(row - 1) * rect.width + col];

          if (upID != mapID) {
            var index1 = MaxBlockNum * upID + mapID,
                index2 = MaxBlockNum * mapID + upID;
            neighbourInfo[index1] = 1, neighbourInfo[index2] = 1;
          }
        }

        if (col != 0) {
          var leftID = tempBlockInfo[row * rect.width + col - 1];

          if (leftID != mapID) {
            var _index = MaxBlockNum * leftID + mapID,
                _index2 = MaxBlockNum * mapID + leftID;

            neighbourInfo[_index] = 1, neighbourInfo[_index2] = 1;
          }
        }

        pointsCount[mapID]++;
      }
    }

    var colorList = new Array();
    var colorHighlightList = new Array();
    colorList.push(colorBytes(_Palette.colorIndexMap[0]));
    colorHighlightList.push(colorBytes(_Palette.colorHighLightIndexMap[0]));
    colorData[0] = 0;
    var maxIndex = 0,
        maxPointsCount = 0;

    for (var _i4 = 0; _i4 < MaxBlockNum; _i4++) {
      if (pointsCount[_i4] > maxPointsCount) {
        maxPointsCount = pointsCount[_i4];
        maxIndex = _i4;
      }
    }

    colorData[maxIndex] = 1;
    var colorNoBlock = colorBytes(_Palette.colorIndexMap[1]);
    var colorBCBackground = colorBytes(_Palette.colorIndexMap[0]);
    var colorUsed = [[], [], [], []];
    colorUsed[0].push([maxIndex]);

    for (var _i5 = 1; _i5 < MaxBlockNum; _i5++) {
      if (_i5 == maxIndex) continue;

      if (neighbourInfo[_i5 * MaxBlockNum + _i5] == 0) {
        colorData[_i5] = 0;
        continue;
      } else {
        var colorOccupied = [0, 0, 0, 0, 0];

        for (var j = 1; j < MaxBlockNum; j++) {
          if (neighbourInfo[j * MaxBlockNum + _i5] != 0 && colorData[j] != 0) {
            colorOccupied[colorData[j]] = 1;
          }
        }

        for (var _j = 1; _j < colorOccupied.length; _j++) {
          if (colorOccupied[_j] == 0) {
            var colorID = _j;
            neighbourInfo[_i5 * MaxBlockNum + _i5] = colorID;
            colorData[_i5] = _j;

            colorUsed[_j - 1].push(_i5);

            break;
          }
        }
      }
    }

    for (var _i6 = 0; _i6 < colorUsed.length; _i6++) {
      if (colorUsed[_i6].length == 0) {
        var sourceID = Math.floor((_i6 + 1) / 2) - 1;
        if (colorUsed[sourceID].length <= 1) continue;
        var totalPushTime = 0;

        for (var _j2 = colorUsed[sourceID].length - 1; _j2 >= colorUsed[sourceID].length / 2; _j2--) {
          colorUsed[_i6].push(colorUsed[sourceID][_j2]);

          totalPushTime++;
        }

        for (var _j3 = 0; _j3 < totalPushTime; _j3++) {
          colorUsed[sourceID].pop();
        }
      }
    }

    var maxLength = 0,
        maxID = 0,
        zeroID = -1;

    for (var _i7 = 0; _i7 < colorUsed.length; _i7++) {
      if (colorUsed[_i7].length > maxLength) {
        maxLength = colorUsed[_i7].length;
        maxID = _i7;
      }

      if (colorUsed[_i7].length == 0) zeroID = _i7;
    }

    if (colorUsed[maxID].length >= 2 && zeroID != -1) {
      while (colorUsed[maxID].length > colorUsed[zeroID].length) {
        colorUsed[zeroID].push(colorUsed[maxID][colorUsed[maxID].length - 1]);
        colorUsed[maxID].pop();
      }
    }

    for (var _i8 = 0; _i8 < colorUsed.length; _i8++) {
      for (var _j4 = 0; _j4 < colorUsed[_i8].length; _j4++) {
        var blockIndex = colorUsed[_i8][_j4];
        colorData[blockIndex] = _i8 + 1;
      }
    }

    for (var _i9 = 1; _i9 < colorData.length; _i9++) {
      if (colorData[_i9] != 0) {
        var _colorID = colorData[_i9];
        colorList.push(colorBytes(_Palette.colorIndexMap[_colorID]));
        colorHighlightList.push(colorBytes(_Palette.colorHighLightIndexMap[_colorID]));
      } else {
        colorList.push(0);
        colorHighlightList.push(0);
      }
    }

    for (var _row = rect.height - 1; _row >= 0; --_row) {
      var _offset = map.offset + (_row + rect.top) * map.width;

      var index = (rect.height - 1 - _row) * (rect.width + 1) + 1;

      for (var _col = 0; _col < rect.width; ++_col) {
        var _pixel = map.data[_offset + _col + rect.left];
        if ((_pixel & 0x07) == 0) continue;
        mapPointNum++;

        var _mapID = _pixel >>> 3;

        debugList[_mapID]++;
        var _colorID2 = _mapID;
        var color = (_pixel & 0x07) == 1 ? palette.obstacles : colorList[_colorID2];
        var colorBlock = (_pixel & 0x07) == 1 ? palette.obstacles : colorNoBlock;
        var mapIDName = _mapID + '';
        var colorHighlight = (_pixel & 0x07) == 1 ? palette.obstacles : colorHighlightList[_colorID2];
        var colorBackground = (_pixel & 0x07) == 1 ? palette.obstacles : colorBCBackground;

        if (typeof mapListData[mapIDName] == 'undefined') {
          mapListData[mapIDName] = emptyData.concat();
        }

        if (_mapID >= 0 && _mapID < MaxBlockNum) {
          if ((_pixel & 0x07) != 1) {
            centerInfo[_mapID].x = centerInfo[_mapID].x + _col + rect.left;
            centerInfo[_mapID].y = centerInfo[_mapID].y + _row + rect.top;
            centerInfo[_mapID].count = centerInfo[_mapID].count + 1;

            if (centerInfo[_mapID].minX > _col) {
              centerInfo[_mapID].minX = _col;
            }

            if (centerInfo[_mapID].maxX < _col) {
              centerInfo[_mapID].maxX = _col;
            }
          }

          var startIndex = index + _col;

          for (var _i10 = 0; _i10 < 1; ++_i10) {
            mapListData[mapIDName][startIndex + _i10] = colorHighlight;
            data[startIndex + _i10] = color;
            dataBlockMap[startIndex + _i10] = colorBlock;
            dataBCBackgroundMap[startIndex + _i10] = colorBackground;
          }
        }
      }
    }

    rect.mapArea = Math.round(mapPointNum * 25 / 10000);
    rect.left += map.left;
    rect.top += map.top;

    for (var iterator in mapListData) {
      mapList[iterator] = "data:image/png;base64," + getIndexPngBase64(rect.width, rect.height, mapListData[iterator]);
    }

    delete map.data;
    return _objectSpread(_objectSpread({
      image: "data:image/png;base64," + getIndexPngBase64(rect.width, rect.height, data),
      imageNoBlock: "data:image/png;base64," + getIndexPngBase64(rect.width, rect.height, dataBlockMap),
      imageBlockCleanBackground: "data:image/png;base64," + getIndexPngBase64(rect.width, rect.height, dataBCBackgroundMap)
    }, rect), {}, {
      mapList: mapList,
      data: map,
      centerInfo: centerInfo,
      neighbourInfo: neighbourInfo,
      colorData: colorData,
      isEmpty: false
    });
  }

  function convertCarpetMap(map, carpet) {
    if (!carpet) return {
      image: '',
      capCount: -1
    };
    var length = map.width * map.height;
    if (!carpet.data || !carpet.data.length || carpet.data.length != length) return {
      image: '',
      capCount: -1
    };
    var rect = {};

    for (var i = 0; i < length; ++i) {
      var value = map.data[map.offset + i];
      if ((value & 0x07) === 0) continue;
      rect.top = Math.floor(i / map.width);
      break;
    }

    if (rect.top === undefined) return;

    for (var _i11 = length; _i11 > rect.top * map.width; --_i11) {
      var _value = map.data[map.offset + _i11 - 1];
      if ((_value & 0x07) === 0) continue;
      rect.height = Math.floor((_i11 - 1) / map.width) - rect.top + 1;
      break;
    }

    var top = rect.top * map.width;
    var bottom = top + rect.height * map.width;

    for (var x = 0; x < map.width && rect.left === undefined; ++x) {
      for (var _i12 = top + x; _i12 < bottom; _i12 += map.width) {
        var _value2 = map.data[map.offset + _i12];
        if ((_value2 & 0x07) === 0) continue;
        rect.left = x;
        break;
      }
    }

    for (var _x = map.width; _x > rect.left && rect.width === undefined; --_x) {
      for (var _i13 = top + _x - 1; _i13 < bottom; _i13 += map.width) {
        var _value3 = map.data[map.offset + _i13];
        if ((_value3 & 0x07) === 0) continue;
        rect.width = _x - rect.left;
        break;
      }
    }

    var palette = {
      carpetColor: 23
    };
    var data = new Array((3 * rect.width + 1) * 3 * rect.height);
    fill(data, 0);
    var pixelData = new Array(rect.width * rect.height);
    fill(pixelData, 0);
    var capCount = 0;

    for (var row = rect.height - 1; row >= 0; --row) {
      var offset = (row + rect.top) * map.width;

      for (var col = 0; col < rect.width; ++col) {
        var pixel = carpet.data[offset + col + rect.left];
        if ((pixel & 0x01) == 0) continue;
        capCount++;
        var initIndex = (3 * rect.height - 3 - 3 * row) * (3 * rect.width + 1) + 1 + col * 3;
        var indexArray = [initIndex, initIndex + 1, initIndex + 2, initIndex + 3 * rect.width + 1, initIndex + 3 * rect.width + 2, initIndex + 3 * rect.width + 3, initIndex + 6 * rect.width + 2, initIndex + 6 * rect.width + 3, initIndex + 6 * rect.width + 4];
        data[indexArray[2]] = palette.carpetColor, data[indexArray[4]] = palette.carpetColor, data[indexArray[6]] = palette.carpetColor;
        var pixelIndex = (rect.height - 1 - row) * rect.width + col;
        pixelData[pixelIndex] = 1;
      }
    }

    return {
      image: "data:image/png;base64," + getIndexPngBase64(3 * rect.width, 3 * rect.height, data),
      capData: pixelData,
      capCount: capCount
    };
  }
},1,[2,3,4,10,11,17,18],"projects/com.roborock.tanos/Parser/MapParserPng.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  module.exports = _interopRequireDefault;
},2,[],"node_modules/@babel/runtime/helpers/interopRequireDefault.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  module.exports = _defineProperty;
},3,[],"node_modules/@babel/runtime/helpers/defineProperty.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var arrayWithHoles = _$$_REQUIRE(_dependencyMap[0], "./arrayWithHoles");

  var iterableToArrayLimit = _$$_REQUIRE(_dependencyMap[1], "./iterableToArrayLimit");

  var unsupportedIterableToArray = _$$_REQUIRE(_dependencyMap[2], "./unsupportedIterableToArray");

  var nonIterableRest = _$$_REQUIRE(_dependencyMap[3], "./nonIterableRest");

  function _slicedToArray(arr, i) {
    return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
  }

  module.exports = _slicedToArray;
},4,[5,6,7,9],"node_modules/@babel/runtime/helpers/slicedToArray.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  module.exports = _arrayWithHoles;
},5,[],"node_modules/@babel/runtime/helpers/arrayWithHoles.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !((typeof Symbol === "function" ? Symbol.iterator : "@@iterator") in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  module.exports = _iterableToArrayLimit;
},6,[],"node_modules/@babel/runtime/helpers/iterableToArrayLimit.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var arrayLikeToArray = _$$_REQUIRE(_dependencyMap[0], "./arrayLikeToArray");

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
  }

  module.exports = _unsupportedIterableToArray;
},7,[8],"node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  module.exports = _arrayLikeToArray;
},8,[],"node_modules/@babel/runtime/helpers/arrayLikeToArray.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  module.exports = _nonIterableRest;
},9,[],"node_modules/@babel/runtime/helpers/nonIterableRest.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _extends() {
    module.exports = _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  module.exports = _extends;
},10,[],"node_modules/@babel/runtime/helpers/extends.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.colorHighLightIndexMap = exports.colorIndexMap = exports.colorHighLightMap = exports.colorMap = exports.Palette = void 0;
  var Palette = {
    map: {
      obstacles: '#646464ff',
      obstaclesSleep: '#646464ff',
      space: '#DFDFDFff',
      spaceSleep: '#DFDFDFff',
      path: '#FFFFFFff',
      pathGoto: '#FFFFFFff',
      pathGotoPlan: '#FFFFFFb3',
      line: '#ffffff2E',
      mopPath: '#FFFFFF66'
    },
    block: {
      0: '#B8B4F1ff',
      1: '#FF5757ff',
      2: '#B8B4F1ff',
      3: '#EBF8E6ff',
      4: '#FAA79Fff',
      5: '#FFEED2ff',
      6: '#F1AEF3ff'
    },
    blockHighLight: {
      0: '#B8B4F1ff',
      1: '#FF5757ff',
      2: '#B8B4F1ff',
      3: '#EBF8E6ff',
      4: '#FAA79Fff',
      5: '#FFEED2ff',
      6: '#F1AEF3ff'
    },
    share: {
      title: '#000000',
      subtitle: '#000000'
    },
    anim: {
      Charged: _$$_REQUIRE(_dependencyMap[0], "../Resources/lottie/charging/data.json"),
      Charging: _$$_REQUIRE(_dependencyMap[0], "../Resources/lottie/charging/data.json"),
      Locating: _$$_REQUIRE(_dependencyMap[1], "../Resources/lottie/waiting/data.json"),
      Sleeping: _$$_REQUIRE(_dependencyMap[2], "../Resources/lottie/sleeping/data.json"),
      Waiting: _$$_REQUIRE(_dependencyMap[1], "../Resources/lottie/waiting/data.json"),
      Warning: _$$_REQUIRE(_dependencyMap[3], "../Resources/lottie/warning/data.json")
    }
  };
  exports.Palette = Palette;

  var _require = _$$_REQUIRE(_dependencyMap[4], "./PngColor"),
      colorMap = _require.colorMap,
      colorHighLightMap = _require.colorHighLightMap,
      colorIndexMap = _require.colorIndexMap,
      colorHighLightIndexMap = _require.colorHighLightIndexMap;

  exports.colorHighLightIndexMap = colorHighLightIndexMap;
  exports.colorIndexMap = colorIndexMap;
  exports.colorHighLightMap = colorHighLightMap;
  exports.colorMap = colorMap;
},11,[12,13,14,15,16],"projects/com.roborock.tanos/Common/Palette.js");
__d(function(global, require, _aUnused, _bUnused, module, exports, _cUnused) {
  module.exports = {"v":"5.4.3","fr":24,"ip":0,"op":72,"w":100,"h":100,"nm":"充电中-lottie","ddd":0,"assets":[],"layers":[{"ddd":0,"ind":1,"ty":4,"nm":"形状图层 6","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":0,"s":[1],"e":[50]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":27,"s":[50],"e":[1]},{"t":60}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[50,50,0],"ix":2},"a":{"a":0,"k":[-75.752,-95.752,0],"ix":1},"s":{"a":0,"k":[75,75,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":1,"k":[{"i":{"x":[0,0],"y":[1,1]},"o":{"x":[0.167,0.167],"y":[0.9,0.9]},"n":["0_1_0p167_0p9","0_1_0p167_0p9"],"t":0,"s":[70,70],"e":[100,100]},{"i":{"x":[0.833,0.833],"y":[1,1]},"o":{"x":[0.167,0.167],"y":[0,0]},"n":["0p833_1_0p167_0","0p833_1_0p167_0"],"t":27,"s":[100,100],"e":[90,90]},{"t":60}],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"椭圆路径 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"fl","c":{"a":0,"k":[0.262745098039,0.878431372549,0.552941176471,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[-75.752,-95.752],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"椭圆 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":60,"st":0,"bm":0}],"markers":[]};
},12,[],"projects/com.roborock.tanos/Resources/lottie/charging/data.json");
__d(function(global, require, _aUnused, _bUnused, module, exports, _cUnused) {
  module.exports = {"v":"5.4.3","fr":24,"ip":0,"op":72,"w":100,"h":100,"nm":"等待指令lottie","ddd":0,"assets":[],"layers":[{"ddd":0,"ind":1,"ty":4,"nm":"形状图层 7","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":0,"s":[0],"e":[40]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":24,"s":[40],"e":[60]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":36,"s":[60],"e":[0]},{"t":62}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[50,50,0],"ix":2},"a":{"a":0,"k":[-75.752,-95.752,0],"ix":1},"s":{"a":0,"k":[75,75,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":1,"k":[{"i":{"x":[0.833,0.833],"y":[0.833,0.833]},"o":{"x":[0.167,0.167],"y":[0.167,0.167]},"n":["0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167"],"t":0,"s":[70,70],"e":[100,100]},{"i":{"x":[0.833,0.833],"y":[0.833,0.833]},"o":{"x":[0.167,0.167],"y":[0.167,0.167]},"n":["0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167"],"t":24,"s":[100,100],"e":[100,100]},{"i":{"x":[0.833,0.833],"y":[0.833,0.833]},"o":{"x":[0.167,0.167],"y":[0.167,0.167]},"n":["0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167"],"t":36,"s":[100,100],"e":[90,90]},{"t":62}],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"椭圆路径 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[-75.752,-95.752],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"椭圆 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":66,"st":0,"bm":0}],"markers":[]};
},13,[],"projects/com.roborock.tanos/Resources/lottie/waiting/data.json");
__d(function(global, require, _aUnused, _bUnused, module, exports, _cUnused) {
  module.exports = {"v":"5.4.3","fr":24,"ip":0,"op":72,"w":100,"h":100,"nm":"休眠lottie","ddd":0,"assets":[],"layers":[{"ddd":0,"ind":1,"ty":4,"nm":"形状图层 2","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":21,"s":[0],"e":[100]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":30,"s":[100],"e":[100]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":57,"s":[100],"e":[0]},{"t":75}],"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":42,"s":[0],"e":[-5]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":57,"s":[-5],"e":[5]},{"t":67}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"n":"0p833_0p833_0p167_0p167","t":21,"s":[27.613,76.1,0],"e":[42.337,68.286,0],"to":[2.63749694824219,-3.35000610351562,0],"ti":[-6.10020446777344,-0.46429443359375,0]},{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"n":"0p833_0p833_0p167_0p167","t":46,"s":[42.337,68.286,0],"e":[57.925,62.537,0],"to":[6.10020446777344,0.46429443359375,0],"ti":[-3.66112732887268,4.58728694915771,0]},{"t":67}],"ix":2},"a":{"a":0,"k":[-100.812,-27.062,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0,0,0],"y":[1,1,1]},"o":{"x":[0.167,0.167,0.167],"y":[0.146,0.146,11.667]},"n":["0_1_0p167_0p146","0_1_0p167_0p146","0_1_0p167_11p667"],"t":21,"s":[30,30,100],"e":[110,110,100]},{"t":34}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-86.99,-42.316],[-100.425,-42.616],[-101.098,-39.583],[-91.787,-39.475],[-100.083,-31.135],[-100.22,-28.086],[-85.917,-27.91],[-86.375,-30.719],[-96,-30.75],[-87.272,-39.167]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.2,0.517647058824,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"形状 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":21,"op":237,"st":21,"bm":0},{"ddd":0,"ind":2,"ty":4,"nm":"形状图层 1","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":0,"s":[0],"e":[100]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":9,"s":[100],"e":[100]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":36,"s":[100],"e":[0]},{"t":54}],"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":21,"s":[0],"e":[-10]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":36,"s":[-10],"e":[-5]},{"t":46}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0,"y":0.216},"o":{"x":0,"y":0},"n":"0_0p216_0_0","t":0,"s":[28.3,59.038,0],"e":[46.837,54.911,0],"to":[2.82499694824219,1.46249389648438,0],"ti":[-4.66270446777344,5.72320556640625,0]},{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"n":"0p833_0p833_0p167_0p167","t":25,"s":[46.837,54.911,0],"e":[60.8,44.6,0],"to":[4.66270446777344,-5.72320556640625,0],"ti":[-7.2236270904541,0.89978700876236,0]},{"t":46}],"ix":2},"a":{"a":0,"k":[-100.812,-27.062,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0,0,0],"y":[1,1,1]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,18.333]},"n":["0_1_0p167_0p167","0_1_0p167_0p167","0_1_0p167_18p333"],"t":0,"s":[30,30,100],"e":[140,140,100]},{"t":9}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-87.159,-42.926],[-100.136,-43.158],[-101.051,-40.071],[-91.937,-39.896],[-100.083,-31.135],[-100.135,-28.383],[-86.922,-27.851],[-86.375,-30.719],[-96,-30.75],[-87.25,-40.104]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.2,0.517647058824,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"形状 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":216,"st":0,"bm":0}],"markers":[]};
},14,[],"projects/com.roborock.tanos/Resources/lottie/sleeping/data.json");
__d(function(global, require, _aUnused, _bUnused, module, exports, _cUnused) {
  module.exports = {"v":"5.4.3","fr":24,"ip":0,"op":24,"w":100,"h":100,"nm":"警告报错lottie","ddd":0,"assets":[],"layers":[{"ddd":0,"ind":1,"ty":4,"nm":"形状图层 3","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":0,"s":[20],"e":[50]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":3,"s":[50],"e":[20]},{"t":6}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[50,50,0],"ix":2},"a":{"a":0,"k":[-75.752,-95.752,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":1,"k":[{"i":{"x":[0.682,0.682],"y":[0.991,0.991]},"o":{"x":[0.052,0.052],"y":[0.002,0.002]},"n":["0p682_0p991_0p052_0p002","0p682_0p991_0p052_0p002"],"t":0,"s":[70,70],"e":[90,90]},{"i":{"x":[0.981,0.981],"y":[1,1]},"o":{"x":[0.299,0.299],"y":[0,0]},"n":["0p981_1_0p299_0","0p981_1_0p299_0"],"t":3,"s":[90,90],"e":[70,70]},{"t":6}],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"椭圆路径 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[-75.752,-95.752],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"椭圆 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":216,"st":0,"bm":0}],"markers":[]};
},15,[],"projects/com.roborock.tanos/Resources/lottie/warning/data.json");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.colorHighLightIndexMap = exports.colorIndexMap = exports.colorHighLightMap = exports.colorMap = void 0;
  var colorMap = ['#DFDFDFff', '#71CBDEff', '#FDD352ff', '#F58E6Eff', '#91C8FFff', '#D5E9FCff', '#EDEDEDff', '#EBF8E6ff', '#E4E4D7ff', '#FFD5D1ff'];
  exports.colorMap = colorMap;
  var colorHighLightMap = ['#DFDFDFff', '#00ADD2ff', '#F8B700ff', '#F16438ff', '#1884F0ff', '#90C6FBff', '#EDBFBFff', '#B4EFADff', '#E1DCAAff', '#FAA79Fff'];
  exports.colorHighLightMap = colorHighLightMap;
  var colorIndexMap = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13];
  exports.colorIndexMap = colorIndexMap;
  var colorHighLightIndexMap = [4, 14, 15, 16, 17, 18, 19, 20, 21, 22];
  exports.colorHighLightIndexMap = colorHighLightIndexMap;
},16,[],"projects/com.roborock.tanos/Common/PngColor.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.BytesToInt = BytesToInt;
  exports.BytesToHexString = BytesToHexString;
  exports.BytesToASCII = BytesToASCII;
  exports.fromSqmmToSqm = fromSqmmToSqm;
  exports.fromSecToMin = fromSecToMin;
  exports.fromMinToHour = fromMinToHour;
  exports.fromSecToHour = fromSecToHour;
  exports.fill = fill;

  function BytesToInt(buffer, offset, len) {
    var result = 0;

    for (var i = 0; i < len; i++) {
      result |= (0x000000FF & parseInt(buffer[i + offset])) << 8 * i;
    }

    return result;
  }

  function BytesToHexString(bytes, offset, len) {
    if (len == 0) return "";
    if (!offset) offset = 0;
    if (!len) len = bytes.length;
    var w = "";

    for (var i = offset; i < offset + len; i++) {
      var str = bytes[i].toString(16);
      w += str.length == 1 ? '0' + str : str;
    }

    return w;
  }

  function BytesToASCII(bytes, offset, len) {
    if (len == 0) return "";
    if (!offset) offset = 0;
    if (!len) len = bytes.length;
    var w = "";

    for (var i = offset; i < offset + len; i++) {
      var str = String.fromCharCode(parseInt(bytes[i]));
      w += str;
    }

    return w;
  }

  function fromSqmmToSqm(number) {
    return Math.round(number / 1000000);
  }

  function fromSecToMin(number) {
    return Math.round(number / 60);
  }

  function fromMinToHour(number) {
    return Math.round(number / 60);
  }

  function fromSecToHour(number) {
    return Math.round(number / 3600);
  }

  function fill(array, value) {
    if (!array) return;

    for (var i = 0; i < array.length; i++) {
      array[i] = value;
    }
  }
},17,[],"projects/com.roborock.tanos/Utils/Converter.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireWildcard = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireWildcard");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getPngBase64 = getPngBase64;
  exports.getIndexPngBase64 = makeIndexedPNG;
  exports.COLOR_INDEX_BLACK = exports.COLOR_INDEX_WHITE = exports.COLOR_INDEX_TRANSPARENT = void 0;

  var Base64 = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[1], "base64-js"));

  var pako = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2], "./deflate_mini"));

  var PNG_SIGNATURE = new Uint8Array([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]);
  var TYPE_PNG_IHDR = new Uint8Array([0x49, 0x48, 0x44, 0x52]);
  var TYPE_PNG_PLTE = new Uint8Array([0x50, 0x4C, 0x54, 0x45]);
  var TYPE_PNG_tRNS = new Uint8Array([0x74, 0x52, 0x4E, 0x53]);
  var TYPE_PNG_IDAT = new Uint8Array([0x49, 0x44, 0x41, 0x54]);
  var CHUNK_PNG_IEND = new Uint8Array([0, 0, 0, 0, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82]);
  var CHUNK_PNG_PLTE;
  var CHUNK_PNG_tRNS;
  var CHUNK_HEADER_LEN = 8;
  var CHUNK_IHDR_LEN = 25;
  var COLOR_TYPE_RGBA = 6;
  var COLOR_TYPE_INDEXED = 3;
  var BIT_DEPTH = 8;
  var PLTE_ENTRIES = 24;
  var TRNS_ENTRIES = 24;
  var COLOR_INDEX_TRANSPARENT = 0;
  exports.COLOR_INDEX_TRANSPARENT = COLOR_INDEX_TRANSPARENT;
  var COLOR_INDEX_WHITE = 1;
  exports.COLOR_INDEX_WHITE = COLOR_INDEX_WHITE;
  var COLOR_INDEX_BLACK = 2;
  exports.COLOR_INDEX_BLACK = COLOR_INDEX_BLACK;

  function makeTable() {
    var c,
        table = [];

    for (var n = 0; n < 256; n++) {
      c = n;

      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
      }

      table[n] = c;
    }

    return table;
  }

  var crc_table = makeTable();

  function update_crc(crc, buf, pos, len) {
    var end = pos + len;
    crc ^= -1;

    for (var i = pos; i < end; i++) {
      crc = crc >>> 8 ^ crc_table[(crc ^ buf[i]) & 0xFF];
    }

    return crc ^ -1;
  }

  function crc32(buf, pos, len) {
    return update_crc(0, buf, pos, len);
  }

  function intBytesBE(value, bytes, offset) {
    for (var i = 0; i < 4; ++i) {
      bytes[offset + i] = value >>> (3 - i) * 8 & 0xff;
    }
  }

  function fillChunkHeader(buffer, offset, dataLen, type) {
    intBytesBE(dataLen, buffer, offset);
    buffer.set(type, offset + 4);
  }

  function fillIHDR(width, height, buffer, offset, colortype) {
    fillChunkHeader(buffer, offset, 13, TYPE_PNG_IHDR);
    intBytesBE(width, buffer, offset + 8);
    intBytesBE(height, buffer, offset + 12);
    buffer[offset + 16] = BIT_DEPTH;
    buffer[offset + 17] = colortype;
    buffer[offset + 18] = 0;
    buffer[offset + 19] = 0;
    buffer[offset + 20] = 0;
    var c = crc32(buffer, offset + 4, 17);
    intBytesBE(c, buffer, offset + 21);
  }

  function makePLTE() {
    var size = CHUNK_HEADER_LEN + 3 * PLTE_ENTRIES + 4;
    CHUNK_PNG_PLTE = new Uint8Array(size);
    fillChunkHeader(CHUNK_PNG_PLTE, 0, 3 * PLTE_ENTRIES, TYPE_PNG_PLTE);
    var idx = 7;
    CHUNK_PNG_PLTE[++idx] = 0;
    CHUNK_PNG_PLTE[++idx] = 0;
    CHUNK_PNG_PLTE[++idx] = 0;
    CHUNK_PNG_PLTE[++idx] = 0xFF;
    CHUNK_PNG_PLTE[++idx] = 0xFF;
    CHUNK_PNG_PLTE[++idx] = 0xFF;
    CHUNK_PNG_PLTE[++idx] = 0;
    CHUNK_PNG_PLTE[++idx] = 0;
    CHUNK_PNG_PLTE[++idx] = 0;
    CHUNK_PNG_PLTE[++idx] = 0x64;
    CHUNK_PNG_PLTE[++idx] = 0x64;
    CHUNK_PNG_PLTE[++idx] = 0x64;
    CHUNK_PNG_PLTE[++idx] = 0xCF;
    CHUNK_PNG_PLTE[++idx] = 0xCF;
    CHUNK_PNG_PLTE[++idx] = 0xCF;
    CHUNK_PNG_PLTE[++idx] = 0x71;
    CHUNK_PNG_PLTE[++idx] = 0xCB;
    CHUNK_PNG_PLTE[++idx] = 0xDE;
    CHUNK_PNG_PLTE[++idx] = 0xFD;
    CHUNK_PNG_PLTE[++idx] = 0xD3;
    CHUNK_PNG_PLTE[++idx] = 0x52;
    CHUNK_PNG_PLTE[++idx] = 0xF5;
    CHUNK_PNG_PLTE[++idx] = 0x8E;
    CHUNK_PNG_PLTE[++idx] = 0x6E;
    CHUNK_PNG_PLTE[++idx] = 0x91;
    CHUNK_PNG_PLTE[++idx] = 0xC8;
    CHUNK_PNG_PLTE[++idx] = 0xFF;
    CHUNK_PNG_PLTE[++idx] = 0xD5;
    CHUNK_PNG_PLTE[++idx] = 0xE9;
    CHUNK_PNG_PLTE[++idx] = 0xFC;
    CHUNK_PNG_PLTE[++idx] = 0xED;
    CHUNK_PNG_PLTE[++idx] = 0xED;
    CHUNK_PNG_PLTE[++idx] = 0xED;
    CHUNK_PNG_PLTE[++idx] = 0xEB;
    CHUNK_PNG_PLTE[++idx] = 0xF8;
    CHUNK_PNG_PLTE[++idx] = 0xE6;
    CHUNK_PNG_PLTE[++idx] = 0xE4;
    CHUNK_PNG_PLTE[++idx] = 0xF4;
    CHUNK_PNG_PLTE[++idx] = 0xD7;
    CHUNK_PNG_PLTE[++idx] = 0xFF;
    CHUNK_PNG_PLTE[++idx] = 0xD5;
    CHUNK_PNG_PLTE[++idx] = 0xD1;
    CHUNK_PNG_PLTE[++idx] = 0x07;
    CHUNK_PNG_PLTE[++idx] = 0x98;
    CHUNK_PNG_PLTE[++idx] = 0xB7;
    CHUNK_PNG_PLTE[++idx] = 0xF8;
    CHUNK_PNG_PLTE[++idx] = 0xB7;
    CHUNK_PNG_PLTE[++idx] = 0x00;
    CHUNK_PNG_PLTE[++idx] = 0xF1;
    CHUNK_PNG_PLTE[++idx] = 0x64;
    CHUNK_PNG_PLTE[++idx] = 0x38;
    CHUNK_PNG_PLTE[++idx] = 0x18;
    CHUNK_PNG_PLTE[++idx] = 0x84;
    CHUNK_PNG_PLTE[++idx] = 0xF0;
    CHUNK_PNG_PLTE[++idx] = 0x90;
    CHUNK_PNG_PLTE[++idx] = 0xC6;
    CHUNK_PNG_PLTE[++idx] = 0xFB;
    CHUNK_PNG_PLTE[++idx] = 0xED;
    CHUNK_PNG_PLTE[++idx] = 0xBF;
    CHUNK_PNG_PLTE[++idx] = 0xBF;
    CHUNK_PNG_PLTE[++idx] = 0xB4;
    CHUNK_PNG_PLTE[++idx] = 0xEF;
    CHUNK_PNG_PLTE[++idx] = 0xAD;
    CHUNK_PNG_PLTE[++idx] = 0xE1;
    CHUNK_PNG_PLTE[++idx] = 0xDC;
    CHUNK_PNG_PLTE[++idx] = 0xAA;
    CHUNK_PNG_PLTE[++idx] = 0xFA;
    CHUNK_PNG_PLTE[++idx] = 0xA7;
    CHUNK_PNG_PLTE[++idx] = 0x9F;
    CHUNK_PNG_PLTE[++idx] = 0;
    CHUNK_PNG_PLTE[++idx] = 0;
    CHUNK_PNG_PLTE[++idx] = 0;
    var crc = crc32(CHUNK_PNG_PLTE, 4, 4 + 3 * PLTE_ENTRIES);
    intBytesBE(crc, CHUNK_PNG_PLTE, size - 4);
  }

  function makeTRNS() {
    var size = CHUNK_HEADER_LEN + TRNS_ENTRIES + 4;
    CHUNK_PNG_tRNS = new Uint8Array(size);
    fillChunkHeader(CHUNK_PNG_tRNS, 0, TRNS_ENTRIES, TYPE_PNG_tRNS);
    var idx = 7;
    CHUNK_PNG_tRNS[++idx] = 0;
    CHUNK_PNG_tRNS[++idx] = 0xFF;
    CHUNK_PNG_tRNS[++idx] = 0xFF;
    CHUNK_PNG_tRNS[++idx] = 0xFF;
    CHUNK_PNG_tRNS[++idx] = 0xFF;
    CHUNK_PNG_tRNS[++idx] = 0xFF;
    CHUNK_PNG_tRNS[++idx] = 0xFF;
    CHUNK_PNG_tRNS[++idx] = 0xFF;
    CHUNK_PNG_tRNS[++idx] = 0xFF;
    CHUNK_PNG_tRNS[++idx] = 0xFF;
    CHUNK_PNG_tRNS[++idx] = 0xFF;
    CHUNK_PNG_tRNS[++idx] = 0xFF;
    CHUNK_PNG_tRNS[++idx] = 0xFF;
    CHUNK_PNG_tRNS[++idx] = 0xFF;
    CHUNK_PNG_tRNS[++idx] = 0xFF;
    CHUNK_PNG_tRNS[++idx] = 0xFF;
    CHUNK_PNG_tRNS[++idx] = 0xFF;
    CHUNK_PNG_tRNS[++idx] = 0xFF;
    CHUNK_PNG_tRNS[++idx] = 0xFF;
    CHUNK_PNG_tRNS[++idx] = 0xFF;
    CHUNK_PNG_tRNS[++idx] = 0xFF;
    CHUNK_PNG_tRNS[++idx] = 0xFF;
    CHUNK_PNG_tRNS[++idx] = 0xFF;
    CHUNK_PNG_tRNS[++idx] = 0x33;
    var crc = crc32(CHUNK_PNG_tRNS, 4, 4 + TRNS_ENTRIES);
    intBytesBE(crc, CHUNK_PNG_tRNS, size - 4);
  }

  function getPngBase64(width, height, rgbaData) {
    var compressed = pako.deflate(rgbaData, {
      level: 1
    });
    var data = new Uint8Array(PNG_SIGNATURE.length + CHUNK_IHDR_LEN + CHUNK_HEADER_LEN + compressed.length + 4 + CHUNK_PNG_IEND.length);
    data.set(PNG_SIGNATURE, 0);
    var offset = PNG_SIGNATURE.length;
    fillIHDR(width, height, data, offset, COLOR_TYPE_RGBA);
    offset += CHUNK_IHDR_LEN;
    fillChunkHeader(data, offset, compressed.length, TYPE_PNG_IDAT);
    offset += CHUNK_HEADER_LEN;
    data.set(compressed, offset);
    var c = crc32(TYPE_PNG_IDAT, 0, 4);
    c = update_crc(c, compressed, 0, compressed.length);
    offset += compressed.length;
    intBytesBE(c, data, offset);
    data.set(CHUNK_PNG_IEND, data.length - CHUNK_PNG_IEND.length);

    if (false) {
      return NativeBase64.fromByteArray(data);
    }

    return Base64.fromByteArray(data);
  }

  function makeIndexedPNG(width, height, pixel) {
    if (!CHUNK_PNG_PLTE) {
      makePLTE();
    }

    if (!CHUNK_PNG_tRNS) {
      makeTRNS();
    }

    var compressed = pako.deflate(pixel, {
      level: 1
    });
    var length = PNG_SIGNATURE.length + CHUNK_IHDR_LEN;
    length += CHUNK_PNG_PLTE.length + CHUNK_PNG_tRNS.length;
    length += CHUNK_HEADER_LEN + compressed.length + 4 + CHUNK_PNG_IEND.length;
    var data = new Uint8Array(length);
    data.set(PNG_SIGNATURE, 0);
    var offset = PNG_SIGNATURE.length;
    fillIHDR(width, height, data, offset, COLOR_TYPE_INDEXED);
    offset += CHUNK_IHDR_LEN;
    data.set(CHUNK_PNG_PLTE, offset);
    offset += CHUNK_PNG_PLTE.length;
    data.set(CHUNK_PNG_tRNS, offset);
    offset += CHUNK_PNG_tRNS.length;
    fillChunkHeader(data, offset, compressed.length, TYPE_PNG_IDAT);
    offset += CHUNK_HEADER_LEN;
    data.set(compressed, offset);
    var c = crc32(TYPE_PNG_IDAT, 0, 4);
    c = update_crc(c, compressed, 0, compressed.length);
    offset += compressed.length;
    intBytesBE(c, data, offset);
    data.set(CHUNK_PNG_IEND, data.length - CHUNK_PNG_IEND.length);

    if (false) {
      return NativeBase64.fromByteArray(data);
    }

    return Base64.fromByteArray(data);
  }

  function example() {
    var width = 100;
    var height = 100;
    var bytebuffer = new Uint8Array((width * 4 + 1) * height);

    for (var i = 0; i < height; i++) {
      bytebuffer[i * (4 * width + 1)] = 0;

      for (var j = 0; j < width; j++) {
        var idx = i * (4 * width + 1) + j * 4 + 1;
        bytebuffer[idx++] = 0;
        bytebuffer[idx++] = 0xFF;
        bytebuffer[idx++] = 0;
        bytebuffer[idx] = 0x2F;
      }
    }

    return getPngBase64(width, height, bytebuffer);
  }

  function example2() {
    var width = 100;
    var height = 100;
    var bytebuffer = new Uint8Array((width + 1) * height);

    for (var i = 0; i < height; i++) {
      for (var j = 0; j < width; j++) {
        var idx = i * (width + 1) + j + 1;
        var color = void 0;

        if (i < height / 2 && j < width / 2) {
          color = COLOR_INDEX_TRANSPARENT;
        } else if (j < width / 2) {
          color = COLOR_INDEX_RED;
        } else if (i < height / 2) {
          color = COLOR_INDEX_BLUE;
        } else {
          color = COLOR_INDEX_GREEN;
        }

        bytebuffer[idx] = color;
      }
    }

    return makeIndexedPNG(width, height, bytebuffer);
  }
},18,[19,21,22],"projects/com.roborock.tanos/Parser/png/png.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _typeof = _$$_REQUIRE(_dependencyMap[0], "../helpers/typeof");

  function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();

    _getRequireWildcardCache = function _getRequireWildcardCache() {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
      return {
        "default": obj
      };
    }

    var cache = _getRequireWildcardCache();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj["default"] = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  module.exports = _interopRequireWildcard;
},19,[20],"node_modules/@babel/runtime/helpers/interopRequireWildcard.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof (typeof Symbol === "function" ? Symbol.iterator : "@@iterator") === "symbol") {
      module.exports = _typeof = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      module.exports = _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== (typeof Symbol === "function" ? Symbol.prototype : "@@prototype") ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  module.exports = _typeof;
},20,[],"node_modules/@babel/runtime/helpers/typeof.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  exports.byteLength = byteLength;
  exports.toByteArray = toByteArray;
  exports.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;

  function getLens(b64) {
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4');
    }

    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }

  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }

  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }

  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;

    for (i = 0; i < len; i += 4) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[curByte++] = tmp >> 16 & 0xFF;
      arr[curByte++] = tmp >> 8 & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }

    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[curByte++] = tmp & 0xFF;
    }

    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }

    return arr;
  }

  function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
  }

  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];

    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
      output.push(tripletToBase64(tmp));
    }

    return output.join('');
  }

  function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3;
    var parts = [];
    var maxChunkLength = 16383;

    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    }

    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
    }

    return parts.join('');
  }
},21,[],"node_modules/base64-js/index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  !function (t) {
    if ("object" == typeof exports && "undefined" != typeof module) module.exports = t();else if ("function" == typeof define && define.amd) define([], t);else {
      ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).pako = t();
    }
  }(function () {
    return function t(e, a, n) {
      function r(s, h) {
        if (!a[s]) {
          if (!e[s]) {
            var l = "function" == typeof _$$_REQUIRE && _$$_REQUIRE;
            if (!h && l) return l(s, !0);
            if (i) return i(s, !0);
            var o = new Error("Cannot find module '" + s + "'");
            throw o.code = "MODULE_NOT_FOUND", o;
          }

          var _ = a[s] = {
            exports: {}
          };

          e[s][0].call(_.exports, function (t) {
            var a = e[s][1][t];
            return r(a || t);
          }, _, _.exports, t, e, a, n);
        }

        return a[s].exports;
      }

      for (var i = "function" == typeof _$$_REQUIRE && _$$_REQUIRE, s = 0; s < n.length; s++) {
        r(n[s]);
      }

      return r;
    }({
      1: [function (t, e, a) {
        "use strict";

        function n(t, e) {
          return Object.prototype.hasOwnProperty.call(t, e);
        }

        var r = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
        a.assign = function (t) {
          for (var e = Array.prototype.slice.call(arguments, 1); e.length;) {
            var a = e.shift();

            if (a) {
              if ("object" != typeof a) throw new TypeError(a + "must be non-object");

              for (var r in a) {
                n(a, r) && (t[r] = a[r]);
              }
            }
          }

          return t;
        }, a.shrinkBuf = function (t, e) {
          return t.length === e ? t : t.subarray ? t.subarray(0, e) : (t.length = e, t);
        };
        var i = {
          arraySet: function arraySet(t, e, a, n, r) {
            if (e.subarray && t.subarray) t.set(e.subarray(a, a + n), r);else for (var i = 0; i < n; i++) {
              t[r + i] = e[a + i];
            }
          },
          flattenChunks: function flattenChunks(t) {
            var e, a, n, r, i, s;

            for (n = 0, e = 0, a = t.length; e < a; e++) {
              n += t[e].length;
            }

            for (s = new Uint8Array(n), r = 0, e = 0, a = t.length; e < a; e++) {
              i = t[e], s.set(i, r), r += i.length;
            }

            return s;
          }
        },
            s = {
          arraySet: function arraySet(t, e, a, n, r) {
            for (var i = 0; i < n; i++) {
              t[r + i] = e[a + i];
            }
          },
          flattenChunks: function flattenChunks(t) {
            return [].concat.apply([], t);
          }
        };
        a.setTyped = function (t) {
          t ? (a.Buf8 = Uint8Array, a.Buf16 = Uint16Array, a.Buf32 = Int32Array, a.assign(a, i)) : (a.Buf8 = Array, a.Buf16 = Array, a.Buf32 = Array, a.assign(a, s));
        }, a.setTyped(r);
      }, {}],
      2: [function (t, e, a) {
        "use strict";

        function n(t, e) {
          if (e < 65537 && (t.subarray && s || !t.subarray && i)) return String.fromCharCode.apply(null, r.shrinkBuf(t, e));

          for (var a = "", n = 0; n < e; n++) {
            a += String.fromCharCode(t[n]);
          }

          return a;
        }

        var r = t("./common"),
            i = !0,
            s = !0;

        try {
          String.fromCharCode.apply(null, [0]);
        } catch (t) {
          i = !1;
        }

        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (t) {
          s = !1;
        }

        for (var h = new r.Buf8(256), l = 0; l < 256; l++) {
          h[l] = l >= 252 ? 6 : l >= 248 ? 5 : l >= 240 ? 4 : l >= 224 ? 3 : l >= 192 ? 2 : 1;
        }

        h[254] = h[254] = 1, a.string2buf = function (t) {
          var e,
              a,
              n,
              i,
              s,
              h = t.length,
              l = 0;

          for (i = 0; i < h; i++) {
            55296 == (64512 & (a = t.charCodeAt(i))) && i + 1 < h && 56320 == (64512 & (n = t.charCodeAt(i + 1))) && (a = 65536 + (a - 55296 << 10) + (n - 56320), i++), l += a < 128 ? 1 : a < 2048 ? 2 : a < 65536 ? 3 : 4;
          }

          for (e = new r.Buf8(l), s = 0, i = 0; s < l; i++) {
            55296 == (64512 & (a = t.charCodeAt(i))) && i + 1 < h && 56320 == (64512 & (n = t.charCodeAt(i + 1))) && (a = 65536 + (a - 55296 << 10) + (n - 56320), i++), a < 128 ? e[s++] = a : a < 2048 ? (e[s++] = 192 | a >>> 6, e[s++] = 128 | 63 & a) : a < 65536 ? (e[s++] = 224 | a >>> 12, e[s++] = 128 | a >>> 6 & 63, e[s++] = 128 | 63 & a) : (e[s++] = 240 | a >>> 18, e[s++] = 128 | a >>> 12 & 63, e[s++] = 128 | a >>> 6 & 63, e[s++] = 128 | 63 & a);
          }

          return e;
        }, a.buf2binstring = function (t) {
          return n(t, t.length);
        }, a.binstring2buf = function (t) {
          for (var e = new r.Buf8(t.length), a = 0, n = e.length; a < n; a++) {
            e[a] = t.charCodeAt(a);
          }

          return e;
        }, a.buf2string = function (t, e) {
          var a,
              r,
              i,
              s,
              l = e || t.length,
              o = new Array(2 * l);

          for (r = 0, a = 0; a < l;) {
            if ((i = t[a++]) < 128) o[r++] = i;else if ((s = h[i]) > 4) o[r++] = 65533, a += s - 1;else {
              for (i &= 2 === s ? 31 : 3 === s ? 15 : 7; s > 1 && a < l;) {
                i = i << 6 | 63 & t[a++], s--;
              }

              s > 1 ? o[r++] = 65533 : i < 65536 ? o[r++] = i : (i -= 65536, o[r++] = 55296 | i >> 10 & 1023, o[r++] = 56320 | 1023 & i);
            }
          }

          return n(o, r);
        }, a.utf8border = function (t, e) {
          var a;

          for ((e = e || t.length) > t.length && (e = t.length), a = e - 1; a >= 0 && 128 == (192 & t[a]);) {
            a--;
          }

          return a < 0 ? e : 0 === a ? e : a + h[t[a]] > e ? a : e;
        };
      }, {
        "./common": 1
      }],
      3: [function (t, e, a) {
        "use strict";

        e.exports = function (t, e, a, n) {
          for (var r = 65535 & t | 0, i = t >>> 16 & 65535 | 0, s = 0; 0 !== a;) {
            a -= s = a > 2e3 ? 2e3 : a;

            do {
              i = i + (r = r + e[n++] | 0) | 0;
            } while (--s);

            r %= 65521, i %= 65521;
          }

          return r | i << 16 | 0;
        };
      }, {}],
      4: [function (t, e, a) {
        "use strict";

        var n = function () {
          for (var t, e = [], a = 0; a < 256; a++) {
            t = a;

            for (var n = 0; n < 8; n++) {
              t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1;
            }

            e[a] = t;
          }

          return e;
        }();

        e.exports = function (t, e, a, r) {
          var i = n,
              s = r + a;
          t ^= -1;

          for (var h = r; h < s; h++) {
            t = t >>> 8 ^ i[255 & (t ^ e[h])];
          }

          return -1 ^ t;
        };
      }, {}],
      5: [function (t, e, a) {
        "use strict";

        function n(t, e) {
          return t.msg = S[e], e;
        }

        function r(t) {
          return (t << 1) - (t > 4 ? 9 : 0);
        }

        function i(t) {
          for (var e = t.length; --e >= 0;) {
            t[e] = 0;
          }
        }

        function s(t) {
          var e = t.state,
              a = e.pending;
          a > t.avail_out && (a = t.avail_out), 0 !== a && (x.arraySet(t.output, e.pending_buf, e.pending_out, a, t.next_out), t.next_out += a, e.pending_out += a, t.total_out += a, t.avail_out -= a, e.pending -= a, 0 === e.pending && (e.pending_out = 0));
        }

        function h(t, e) {
          B._tr_flush_block(t, t.block_start >= 0 ? t.block_start : -1, t.strstart - t.block_start, e), t.block_start = t.strstart, s(t.strm);
        }

        function l(t, e) {
          t.pending_buf[t.pending++] = e;
        }

        function o(t, e) {
          t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = 255 & e;
        }

        function _(t, e, a, n) {
          var r = t.avail_in;
          return r > n && (r = n), 0 === r ? 0 : (t.avail_in -= r, x.arraySet(e, t.input, t.next_in, r, a), 1 === t.state.wrap ? t.adler = A(t.adler, e, r, a) : 2 === t.state.wrap && (t.adler = C(t.adler, e, r, a)), t.next_in += r, t.total_in += r, r);
        }

        function d(t, e) {
          var a,
              n,
              r = t.max_chain_length,
              i = t.strstart,
              s = t.prev_length,
              h = t.nice_match,
              l = t.strstart > t.w_size - nt ? t.strstart - (t.w_size - nt) : 0,
              o = t.window,
              _ = t.w_mask,
              d = t.prev,
              u = t.strstart + at,
              f = o[i + s - 1],
              c = o[i + s];
          t.prev_length >= t.good_match && (r >>= 2), h > t.lookahead && (h = t.lookahead);

          do {
            if (a = e, o[a + s] === c && o[a + s - 1] === f && o[a] === o[i] && o[++a] === o[i + 1]) {
              i += 2, a++;

              do {} while (o[++i] === o[++a] && o[++i] === o[++a] && o[++i] === o[++a] && o[++i] === o[++a] && o[++i] === o[++a] && o[++i] === o[++a] && o[++i] === o[++a] && o[++i] === o[++a] && i < u);

              if (n = at - (u - i), i = u - at, n > s) {
                if (t.match_start = e, s = n, n >= h) break;
                f = o[i + s - 1], c = o[i + s];
              }
            }
          } while ((e = d[e & _]) > l && 0 != --r);

          return s <= t.lookahead ? s : t.lookahead;
        }

        function u(t) {
          var e,
              a,
              n,
              r,
              i,
              s = t.w_size;

          do {
            if (r = t.window_size - t.lookahead - t.strstart, t.strstart >= s + (s - nt)) {
              x.arraySet(t.window, t.window, s, s, 0), t.match_start -= s, t.strstart -= s, t.block_start -= s, e = a = t.hash_size;

              do {
                n = t.head[--e], t.head[e] = n >= s ? n - s : 0;
              } while (--a);

              e = a = s;

              do {
                n = t.prev[--e], t.prev[e] = n >= s ? n - s : 0;
              } while (--a);

              r += s;
            }

            if (0 === t.strm.avail_in) break;
            if (a = _(t.strm, t.window, t.strstart + t.lookahead, r), t.lookahead += a, t.lookahead + t.insert >= et) for (i = t.strstart - t.insert, t.ins_h = t.window[i], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[i + 1]) & t.hash_mask; t.insert && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[i + et - 1]) & t.hash_mask, t.prev[i & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = i, i++, t.insert--, !(t.lookahead + t.insert < et));) {
              ;
            }
          } while (t.lookahead < nt && 0 !== t.strm.avail_in);
        }

        function f(t, e) {
          for (var a, n;;) {
            if (t.lookahead < nt) {
              if (u(t), t.lookahead < nt && e === j) return ut;
              if (0 === t.lookahead) break;
            }

            if (a = 0, t.lookahead >= et && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + et - 1]) & t.hash_mask, a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), 0 !== a && t.strstart - a <= t.w_size - nt && (t.match_length = d(t, a)), t.match_length >= et) {
              if (n = B._tr_tally(t, t.strstart - t.match_start, t.match_length - et), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= et) {
                t.match_length--;

                do {
                  t.strstart++, t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + et - 1]) & t.hash_mask, a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart;
                } while (0 != --t.match_length);

                t.strstart++;
              } else t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 1]) & t.hash_mask;
            } else n = B._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++;
            if (n && (h(t, !1), 0 === t.strm.avail_out)) return ut;
          }

          return t.insert = t.strstart < et - 1 ? t.strstart : et - 1, e === D ? (h(t, !0), 0 === t.strm.avail_out ? ct : pt) : t.last_lit && (h(t, !1), 0 === t.strm.avail_out) ? ut : ft;
        }

        function c(t, e) {
          for (var a, n, r;;) {
            if (t.lookahead < nt) {
              if (u(t), t.lookahead < nt && e === j) return ut;
              if (0 === t.lookahead) break;
            }

            if (a = 0, t.lookahead >= et && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + et - 1]) & t.hash_mask, a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = et - 1, 0 !== a && t.prev_length < t.max_lazy_match && t.strstart - a <= t.w_size - nt && (t.match_length = d(t, a), t.match_length <= 5 && (t.strategy === H || t.match_length === et && t.strstart - t.match_start > 4096) && (t.match_length = et - 1)), t.prev_length >= et && t.match_length <= t.prev_length) {
              r = t.strstart + t.lookahead - et, n = B._tr_tally(t, t.strstart - 1 - t.prev_match, t.prev_length - et), t.lookahead -= t.prev_length - 1, t.prev_length -= 2;

              do {
                ++t.strstart <= r && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + et - 1]) & t.hash_mask, a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart);
              } while (0 != --t.prev_length);

              if (t.match_available = 0, t.match_length = et - 1, t.strstart++, n && (h(t, !1), 0 === t.strm.avail_out)) return ut;
            } else if (t.match_available) {
              if ((n = B._tr_tally(t, 0, t.window[t.strstart - 1])) && h(t, !1), t.strstart++, t.lookahead--, 0 === t.strm.avail_out) return ut;
            } else t.match_available = 1, t.strstart++, t.lookahead--;
          }

          return t.match_available && (n = B._tr_tally(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < et - 1 ? t.strstart : et - 1, e === D ? (h(t, !0), 0 === t.strm.avail_out ? ct : pt) : t.last_lit && (h(t, !1), 0 === t.strm.avail_out) ? ut : ft;
        }

        function p(t, e) {
          for (var a, n, r, i, s = t.window;;) {
            if (t.lookahead <= at) {
              if (u(t), t.lookahead <= at && e === j) return ut;
              if (0 === t.lookahead) break;
            }

            if (t.match_length = 0, t.lookahead >= et && t.strstart > 0 && (r = t.strstart - 1, (n = s[r]) === s[++r] && n === s[++r] && n === s[++r])) {
              i = t.strstart + at;

              do {} while (n === s[++r] && n === s[++r] && n === s[++r] && n === s[++r] && n === s[++r] && n === s[++r] && n === s[++r] && n === s[++r] && r < i);

              t.match_length = at - (i - r), t.match_length > t.lookahead && (t.match_length = t.lookahead);
            }

            if (t.match_length >= et ? (a = B._tr_tally(t, 1, t.match_length - et), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0) : (a = B._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++), a && (h(t, !1), 0 === t.strm.avail_out)) return ut;
          }

          return t.insert = 0, e === D ? (h(t, !0), 0 === t.strm.avail_out ? ct : pt) : t.last_lit && (h(t, !1), 0 === t.strm.avail_out) ? ut : ft;
        }

        function g(t, e) {
          for (var a;;) {
            if (0 === t.lookahead && (u(t), 0 === t.lookahead)) {
              if (e === j) return ut;
              break;
            }

            if (t.match_length = 0, a = B._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, a && (h(t, !1), 0 === t.strm.avail_out)) return ut;
          }

          return t.insert = 0, e === D ? (h(t, !0), 0 === t.strm.avail_out ? ct : pt) : t.last_lit && (h(t, !1), 0 === t.strm.avail_out) ? ut : ft;
        }

        function m(t, e, a, n, r) {
          this.good_length = t, this.max_lazy = e, this.nice_length = a, this.max_chain = n, this.func = r;
        }

        function b(t) {
          t.window_size = 2 * t.w_size, i(t.head), t.max_lazy_match = z[t.level].max_lazy, t.good_match = z[t.level].good_length, t.nice_match = z[t.level].nice_length, t.max_chain_length = z[t.level].max_chain, t.strstart = 0, t.block_start = 0, t.lookahead = 0, t.insert = 0, t.match_length = t.prev_length = et - 1, t.match_available = 0, t.ins_h = 0;
        }

        function w() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = J, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new x.Buf16(2 * $), this.dyn_dtree = new x.Buf16(2 * (2 * Y + 1)), this.bl_tree = new x.Buf16(2 * (2 * Z + 1)), i(this.dyn_ltree), i(this.dyn_dtree), i(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new x.Buf16(tt + 1), this.heap = new x.Buf16(2 * X + 1), i(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new x.Buf16(2 * X + 1), i(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }

        function v(t) {
          var e;
          return t && t.state ? (t.total_in = t.total_out = 0, t.data_type = G, e = t.state, e.pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = e.wrap ? it : _t, t.adler = 2 === e.wrap ? 0 : 1, e.last_flush = j, B._tr_init(e), O) : n(t, T);
        }

        function y(t) {
          var e = v(t);
          return e === O && b(t.state), e;
        }

        function k(t, e, a, r, i, s) {
          if (!t) return T;
          var h = 1;
          if (e === R && (e = 6), r < 0 ? (h = 0, r = -r) : r > 15 && (h = 2, r -= 16), i < 1 || i > Q || a !== J || r < 8 || r > 15 || e < 0 || e > 9 || s < 0 || s > M) return n(t, T);
          8 === r && (r = 9);
          var l = new w();
          return t.state = l, l.strm = t, l.wrap = h, l.gzhead = null, l.w_bits = r, l.w_size = 1 << l.w_bits, l.w_mask = l.w_size - 1, l.hash_bits = i + 7, l.hash_size = 1 << l.hash_bits, l.hash_mask = l.hash_size - 1, l.hash_shift = ~~((l.hash_bits + et - 1) / et), l.window = new x.Buf8(2 * l.w_size), l.head = new x.Buf16(l.hash_size), l.prev = new x.Buf16(l.w_size), l.lit_bufsize = 1 << i + 6, l.pending_buf_size = 4 * l.lit_bufsize, l.pending_buf = new x.Buf8(l.pending_buf_size), l.d_buf = 1 * l.lit_bufsize, l.l_buf = 3 * l.lit_bufsize, l.level = e, l.strategy = s, l.method = a, y(t);
        }

        var z,
            x = t("../utils/common"),
            B = t("./trees"),
            A = t("./adler32"),
            C = t("./crc32"),
            S = t("./messages"),
            j = 0,
            E = 1,
            U = 3,
            D = 4,
            I = 5,
            O = 0,
            q = 1,
            T = -2,
            L = -3,
            N = -5,
            R = -1,
            H = 1,
            F = 2,
            K = 3,
            M = 4,
            P = 0,
            G = 2,
            J = 8,
            Q = 9,
            V = 15,
            W = 8,
            X = 286,
            Y = 30,
            Z = 19,
            $ = 2 * X + 1,
            tt = 15,
            et = 3,
            at = 258,
            nt = at + et + 1,
            rt = 32,
            it = 42,
            st = 69,
            ht = 73,
            lt = 91,
            ot = 103,
            _t = 113,
            dt = 666,
            ut = 1,
            ft = 2,
            ct = 3,
            pt = 4,
            gt = 3;
        z = [new m(0, 0, 0, 0, function (t, e) {
          var a = 65535;

          for (a > t.pending_buf_size - 5 && (a = t.pending_buf_size - 5);;) {
            if (t.lookahead <= 1) {
              if (u(t), 0 === t.lookahead && e === j) return ut;
              if (0 === t.lookahead) break;
            }

            t.strstart += t.lookahead, t.lookahead = 0;
            var n = t.block_start + a;
            if ((0 === t.strstart || t.strstart >= n) && (t.lookahead = t.strstart - n, t.strstart = n, h(t, !1), 0 === t.strm.avail_out)) return ut;
            if (t.strstart - t.block_start >= t.w_size - nt && (h(t, !1), 0 === t.strm.avail_out)) return ut;
          }

          return t.insert = 0, e === D ? (h(t, !0), 0 === t.strm.avail_out ? ct : pt) : (t.strstart > t.block_start && (h(t, !1), t.strm.avail_out), ut);
        }), new m(4, 4, 8, 4, f), new m(4, 5, 16, 8, f), new m(4, 6, 32, 32, f), new m(4, 4, 16, 16, c), new m(8, 16, 32, 32, c), new m(8, 16, 128, 128, c), new m(8, 32, 128, 256, c), new m(32, 128, 258, 1024, c), new m(32, 258, 258, 4096, c)], a.deflateInit = function (t, e) {
          return k(t, e, J, V, W, P);
        }, a.deflateInit2 = k, a.deflateReset = y, a.deflateResetKeep = v, a.deflateSetHeader = function (t, e) {
          return t && t.state ? 2 !== t.state.wrap ? T : (t.state.gzhead = e, O) : T;
        }, a.deflate = function (t, e) {
          var a, h, _, d;

          if (!t || !t.state || e > I || e < 0) return t ? n(t, T) : T;
          if (h = t.state, !t.output || !t.input && 0 !== t.avail_in || h.status === dt && e !== D) return n(t, 0 === t.avail_out ? N : T);
          if (h.strm = t, a = h.last_flush, h.last_flush = e, h.status === it) if (2 === h.wrap) t.adler = 0, l(h, 31), l(h, 139), l(h, 8), h.gzhead ? (l(h, (h.gzhead.text ? 1 : 0) + (h.gzhead.hcrc ? 2 : 0) + (h.gzhead.extra ? 4 : 0) + (h.gzhead.name ? 8 : 0) + (h.gzhead.comment ? 16 : 0)), l(h, 255 & h.gzhead.time), l(h, h.gzhead.time >> 8 & 255), l(h, h.gzhead.time >> 16 & 255), l(h, h.gzhead.time >> 24 & 255), l(h, 9 === h.level ? 2 : h.strategy >= F || h.level < 2 ? 4 : 0), l(h, 255 & h.gzhead.os), h.gzhead.extra && h.gzhead.extra.length && (l(h, 255 & h.gzhead.extra.length), l(h, h.gzhead.extra.length >> 8 & 255)), h.gzhead.hcrc && (t.adler = C(t.adler, h.pending_buf, h.pending, 0)), h.gzindex = 0, h.status = st) : (l(h, 0), l(h, 0), l(h, 0), l(h, 0), l(h, 0), l(h, 9 === h.level ? 2 : h.strategy >= F || h.level < 2 ? 4 : 0), l(h, gt), h.status = _t);else {
            var u = J + (h.w_bits - 8 << 4) << 8;
            u |= (h.strategy >= F || h.level < 2 ? 0 : h.level < 6 ? 1 : 6 === h.level ? 2 : 3) << 6, 0 !== h.strstart && (u |= rt), u += 31 - u % 31, h.status = _t, o(h, u), 0 !== h.strstart && (o(h, t.adler >>> 16), o(h, 65535 & t.adler)), t.adler = 1;
          }
          if (h.status === st) if (h.gzhead.extra) {
            for (_ = h.pending; h.gzindex < (65535 & h.gzhead.extra.length) && (h.pending !== h.pending_buf_size || (h.gzhead.hcrc && h.pending > _ && (t.adler = C(t.adler, h.pending_buf, h.pending - _, _)), s(t), _ = h.pending, h.pending !== h.pending_buf_size));) {
              l(h, 255 & h.gzhead.extra[h.gzindex]), h.gzindex++;
            }

            h.gzhead.hcrc && h.pending > _ && (t.adler = C(t.adler, h.pending_buf, h.pending - _, _)), h.gzindex === h.gzhead.extra.length && (h.gzindex = 0, h.status = ht);
          } else h.status = ht;
          if (h.status === ht) if (h.gzhead.name) {
            _ = h.pending;

            do {
              if (h.pending === h.pending_buf_size && (h.gzhead.hcrc && h.pending > _ && (t.adler = C(t.adler, h.pending_buf, h.pending - _, _)), s(t), _ = h.pending, h.pending === h.pending_buf_size)) {
                d = 1;
                break;
              }

              d = h.gzindex < h.gzhead.name.length ? 255 & h.gzhead.name.charCodeAt(h.gzindex++) : 0, l(h, d);
            } while (0 !== d);

            h.gzhead.hcrc && h.pending > _ && (t.adler = C(t.adler, h.pending_buf, h.pending - _, _)), 0 === d && (h.gzindex = 0, h.status = lt);
          } else h.status = lt;
          if (h.status === lt) if (h.gzhead.comment) {
            _ = h.pending;

            do {
              if (h.pending === h.pending_buf_size && (h.gzhead.hcrc && h.pending > _ && (t.adler = C(t.adler, h.pending_buf, h.pending - _, _)), s(t), _ = h.pending, h.pending === h.pending_buf_size)) {
                d = 1;
                break;
              }

              d = h.gzindex < h.gzhead.comment.length ? 255 & h.gzhead.comment.charCodeAt(h.gzindex++) : 0, l(h, d);
            } while (0 !== d);

            h.gzhead.hcrc && h.pending > _ && (t.adler = C(t.adler, h.pending_buf, h.pending - _, _)), 0 === d && (h.status = ot);
          } else h.status = ot;

          if (h.status === ot && (h.gzhead.hcrc ? (h.pending + 2 > h.pending_buf_size && s(t), h.pending + 2 <= h.pending_buf_size && (l(h, 255 & t.adler), l(h, t.adler >> 8 & 255), t.adler = 0, h.status = _t)) : h.status = _t), 0 !== h.pending) {
            if (s(t), 0 === t.avail_out) return h.last_flush = -1, O;
          } else if (0 === t.avail_in && r(e) <= r(a) && e !== D) return n(t, N);

          if (h.status === dt && 0 !== t.avail_in) return n(t, N);

          if (0 !== t.avail_in || 0 !== h.lookahead || e !== j && h.status !== dt) {
            var f = h.strategy === F ? g(h, e) : h.strategy === K ? p(h, e) : z[h.level].func(h, e);
            if (f !== ct && f !== pt || (h.status = dt), f === ut || f === ct) return 0 === t.avail_out && (h.last_flush = -1), O;
            if (f === ft && (e === E ? B._tr_align(h) : e !== I && (B._tr_stored_block(h, 0, 0, !1), e === U && (i(h.head), 0 === h.lookahead && (h.strstart = 0, h.block_start = 0, h.insert = 0))), s(t), 0 === t.avail_out)) return h.last_flush = -1, O;
          }

          return e !== D ? O : h.wrap <= 0 ? q : (2 === h.wrap ? (l(h, 255 & t.adler), l(h, t.adler >> 8 & 255), l(h, t.adler >> 16 & 255), l(h, t.adler >> 24 & 255), l(h, 255 & t.total_in), l(h, t.total_in >> 8 & 255), l(h, t.total_in >> 16 & 255), l(h, t.total_in >> 24 & 255)) : (o(h, t.adler >>> 16), o(h, 65535 & t.adler)), s(t), h.wrap > 0 && (h.wrap = -h.wrap), 0 !== h.pending ? O : q);
        }, a.deflateEnd = function (t) {
          var e;
          return t && t.state ? (e = t.state.status) !== it && e !== st && e !== ht && e !== lt && e !== ot && e !== _t && e !== dt ? n(t, T) : (t.state = null, e === _t ? n(t, L) : O) : T;
        }, a.deflateSetDictionary = function (t, e) {
          var a,
              n,
              r,
              s,
              h,
              l,
              o,
              _,
              d = e.length;

          if (!t || !t.state) return T;
          if (a = t.state, 2 === (s = a.wrap) || 1 === s && a.status !== it || a.lookahead) return T;

          for (1 === s && (t.adler = A(t.adler, e, d, 0)), a.wrap = 0, d >= a.w_size && (0 === s && (i(a.head), a.strstart = 0, a.block_start = 0, a.insert = 0), _ = new x.Buf8(a.w_size), x.arraySet(_, e, d - a.w_size, a.w_size, 0), e = _, d = a.w_size), h = t.avail_in, l = t.next_in, o = t.input, t.avail_in = d, t.next_in = 0, t.input = e, u(a); a.lookahead >= et;) {
            n = a.strstart, r = a.lookahead - (et - 1);

            do {
              a.ins_h = (a.ins_h << a.hash_shift ^ a.window[n + et - 1]) & a.hash_mask, a.prev[n & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = n, n++;
            } while (--r);

            a.strstart = n, a.lookahead = et - 1, u(a);
          }

          return a.strstart += a.lookahead, a.block_start = a.strstart, a.insert = a.lookahead, a.lookahead = 0, a.match_length = a.prev_length = et - 1, a.match_available = 0, t.next_in = l, t.input = o, t.avail_in = h, a.wrap = s, O;
        }, a.deflateInfo = "pako deflate (from Nodeca project)";
      }, {
        "../utils/common": 1,
        "./adler32": 3,
        "./crc32": 4,
        "./messages": 6,
        "./trees": 7
      }],
      6: [function (t, e, a) {
        "use strict";

        e.exports = {
          2: "need dictionary",
          1: "stream end",
          0: "",
          "-1": "file error",
          "-2": "stream error",
          "-3": "data error",
          "-4": "insufficient memory",
          "-5": "buffer error",
          "-6": "incompatible version"
        };
      }, {}],
      7: [function (t, e, a) {
        "use strict";

        function n(t) {
          for (var e = t.length; --e >= 0;) {
            t[e] = 0;
          }
        }

        function r(t, e, a, n, r) {
          this.static_tree = t, this.extra_bits = e, this.extra_base = a, this.elems = n, this.max_length = r, this.has_stree = t && t.length;
        }

        function i(t, e) {
          this.dyn_tree = t, this.max_code = 0, this.stat_desc = e;
        }

        function s(t) {
          return t < 256 ? et[t] : et[256 + (t >>> 7)];
        }

        function h(t, e) {
          t.pending_buf[t.pending++] = 255 & e, t.pending_buf[t.pending++] = e >>> 8 & 255;
        }

        function l(t, e, a) {
          t.bi_valid > M - a ? (t.bi_buf |= e << t.bi_valid & 65535, h(t, t.bi_buf), t.bi_buf = e >> M - t.bi_valid, t.bi_valid += a - M) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += a);
        }

        function o(t, e, a) {
          l(t, a[2 * e], a[2 * e + 1]);
        }

        function _(t, e) {
          var a = 0;

          do {
            a |= 1 & t, t >>>= 1, a <<= 1;
          } while (--e > 0);

          return a >>> 1;
        }

        function d(t) {
          16 === t.bi_valid ? (h(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : t.bi_valid >= 8 && (t.pending_buf[t.pending++] = 255 & t.bi_buf, t.bi_buf >>= 8, t.bi_valid -= 8);
        }

        function u(t, e) {
          var a,
              n,
              r,
              i,
              s,
              h,
              l = e.dyn_tree,
              o = e.max_code,
              _ = e.stat_desc.static_tree,
              d = e.stat_desc.has_stree,
              u = e.stat_desc.extra_bits,
              f = e.stat_desc.extra_base,
              c = e.stat_desc.max_length,
              p = 0;

          for (i = 0; i <= K; i++) {
            t.bl_count[i] = 0;
          }

          for (l[2 * t.heap[t.heap_max] + 1] = 0, a = t.heap_max + 1; a < F; a++) {
            (i = l[2 * l[2 * (n = t.heap[a]) + 1] + 1] + 1) > c && (i = c, p++), l[2 * n + 1] = i, n > o || (t.bl_count[i]++, s = 0, n >= f && (s = u[n - f]), h = l[2 * n], t.opt_len += h * (i + s), d && (t.static_len += h * (_[2 * n + 1] + s)));
          }

          if (0 !== p) {
            do {
              for (i = c - 1; 0 === t.bl_count[i];) {
                i--;
              }

              t.bl_count[i]--, t.bl_count[i + 1] += 2, t.bl_count[c]--, p -= 2;
            } while (p > 0);

            for (i = c; 0 !== i; i--) {
              for (n = t.bl_count[i]; 0 !== n;) {
                (r = t.heap[--a]) > o || (l[2 * r + 1] !== i && (t.opt_len += (i - l[2 * r + 1]) * l[2 * r], l[2 * r + 1] = i), n--);
              }
            }
          }
        }

        function f(t, e, a) {
          var n,
              r,
              i = new Array(K + 1),
              s = 0;

          for (n = 1; n <= K; n++) {
            i[n] = s = s + a[n - 1] << 1;
          }

          for (r = 0; r <= e; r++) {
            var h = t[2 * r + 1];
            0 !== h && (t[2 * r] = _(i[h]++, h));
          }
        }

        function c() {
          var t,
              e,
              a,
              n,
              i,
              s = new Array(K + 1);

          for (a = 0, n = 0; n < T - 1; n++) {
            for (nt[n] = a, t = 0; t < 1 << W[n]; t++) {
              at[a++] = n;
            }
          }

          for (at[a - 1] = n, i = 0, n = 0; n < 16; n++) {
            for (rt[n] = i, t = 0; t < 1 << X[n]; t++) {
              et[i++] = n;
            }
          }

          for (i >>= 7; n < R; n++) {
            for (rt[n] = i << 7, t = 0; t < 1 << X[n] - 7; t++) {
              et[256 + i++] = n;
            }
          }

          for (e = 0; e <= K; e++) {
            s[e] = 0;
          }

          for (t = 0; t <= 143;) {
            $[2 * t + 1] = 8, t++, s[8]++;
          }

          for (; t <= 255;) {
            $[2 * t + 1] = 9, t++, s[9]++;
          }

          for (; t <= 279;) {
            $[2 * t + 1] = 7, t++, s[7]++;
          }

          for (; t <= 287;) {
            $[2 * t + 1] = 8, t++, s[8]++;
          }

          for (f($, N + 1, s), t = 0; t < R; t++) {
            tt[2 * t + 1] = 5, tt[2 * t] = _(t, 5);
          }

          it = new r($, W, L + 1, N, K), st = new r(tt, X, 0, R, K), ht = new r(new Array(0), Y, 0, H, P);
        }

        function p(t) {
          var e;

          for (e = 0; e < N; e++) {
            t.dyn_ltree[2 * e] = 0;
          }

          for (e = 0; e < R; e++) {
            t.dyn_dtree[2 * e] = 0;
          }

          for (e = 0; e < H; e++) {
            t.bl_tree[2 * e] = 0;
          }

          t.dyn_ltree[2 * G] = 1, t.opt_len = t.static_len = 0, t.last_lit = t.matches = 0;
        }

        function g(t) {
          t.bi_valid > 8 ? h(t, t.bi_buf) : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0;
        }

        function m(t, e, a, n) {
          g(t), n && (h(t, a), h(t, ~a)), S.arraySet(t.pending_buf, t.window, e, a, t.pending), t.pending += a;
        }

        function b(t, e, a, n) {
          var r = 2 * e,
              i = 2 * a;
          return t[r] < t[i] || t[r] === t[i] && n[e] <= n[a];
        }

        function w(t, e, a) {
          for (var n = t.heap[a], r = a << 1; r <= t.heap_len && (r < t.heap_len && b(e, t.heap[r + 1], t.heap[r], t.depth) && r++, !b(e, n, t.heap[r], t.depth));) {
            t.heap[a] = t.heap[r], a = r, r <<= 1;
          }

          t.heap[a] = n;
        }

        function v(t, e, a) {
          var n,
              r,
              i,
              h,
              _ = 0;
          if (0 !== t.last_lit) do {
            n = t.pending_buf[t.d_buf + 2 * _] << 8 | t.pending_buf[t.d_buf + 2 * _ + 1], r = t.pending_buf[t.l_buf + _], _++, 0 === n ? o(t, r, e) : (o(t, (i = at[r]) + L + 1, e), 0 !== (h = W[i]) && l(t, r -= nt[i], h), o(t, i = s(--n), a), 0 !== (h = X[i]) && l(t, n -= rt[i], h));
          } while (_ < t.last_lit);
          o(t, G, e);
        }

        function y(t, e) {
          var a,
              n,
              r,
              i = e.dyn_tree,
              s = e.stat_desc.static_tree,
              h = e.stat_desc.has_stree,
              l = e.stat_desc.elems,
              o = -1;

          for (t.heap_len = 0, t.heap_max = F, a = 0; a < l; a++) {
            0 !== i[2 * a] ? (t.heap[++t.heap_len] = o = a, t.depth[a] = 0) : i[2 * a + 1] = 0;
          }

          for (; t.heap_len < 2;) {
            i[2 * (r = t.heap[++t.heap_len] = o < 2 ? ++o : 0)] = 1, t.depth[r] = 0, t.opt_len--, h && (t.static_len -= s[2 * r + 1]);
          }

          for (e.max_code = o, a = t.heap_len >> 1; a >= 1; a--) {
            w(t, i, a);
          }

          r = l;

          do {
            a = t.heap[1], t.heap[1] = t.heap[t.heap_len--], w(t, i, 1), n = t.heap[1], t.heap[--t.heap_max] = a, t.heap[--t.heap_max] = n, i[2 * r] = i[2 * a] + i[2 * n], t.depth[r] = (t.depth[a] >= t.depth[n] ? t.depth[a] : t.depth[n]) + 1, i[2 * a + 1] = i[2 * n + 1] = r, t.heap[1] = r++, w(t, i, 1);
          } while (t.heap_len >= 2);

          t.heap[--t.heap_max] = t.heap[1], u(t, e), f(i, o, t.bl_count);
        }

        function k(t, e, a) {
          var n,
              r,
              i = -1,
              s = e[1],
              h = 0,
              l = 7,
              o = 4;

          for (0 === s && (l = 138, o = 3), e[2 * (a + 1) + 1] = 65535, n = 0; n <= a; n++) {
            r = s, s = e[2 * (n + 1) + 1], ++h < l && r === s || (h < o ? t.bl_tree[2 * r] += h : 0 !== r ? (r !== i && t.bl_tree[2 * r]++, t.bl_tree[2 * J]++) : h <= 10 ? t.bl_tree[2 * Q]++ : t.bl_tree[2 * V]++, h = 0, i = r, 0 === s ? (l = 138, o = 3) : r === s ? (l = 6, o = 3) : (l = 7, o = 4));
          }
        }

        function z(t, e, a) {
          var n,
              r,
              i = -1,
              s = e[1],
              h = 0,
              _ = 7,
              d = 4;

          for (0 === s && (_ = 138, d = 3), n = 0; n <= a; n++) {
            if (r = s, s = e[2 * (n + 1) + 1], !(++h < _ && r === s)) {
              if (h < d) do {
                o(t, r, t.bl_tree);
              } while (0 != --h);else 0 !== r ? (r !== i && (o(t, r, t.bl_tree), h--), o(t, J, t.bl_tree), l(t, h - 3, 2)) : h <= 10 ? (o(t, Q, t.bl_tree), l(t, h - 3, 3)) : (o(t, V, t.bl_tree), l(t, h - 11, 7));
              h = 0, i = r, 0 === s ? (_ = 138, d = 3) : r === s ? (_ = 6, d = 3) : (_ = 7, d = 4);
            }
          }
        }

        function x(t) {
          var e;

          for (k(t, t.dyn_ltree, t.l_desc.max_code), k(t, t.dyn_dtree, t.d_desc.max_code), y(t, t.bl_desc), e = H - 1; e >= 3 && 0 === t.bl_tree[2 * Z[e] + 1]; e--) {
            ;
          }

          return t.opt_len += 3 * (e + 1) + 5 + 5 + 4, e;
        }

        function B(t, e, a, n) {
          var r;

          for (l(t, e - 257, 5), l(t, a - 1, 5), l(t, n - 4, 4), r = 0; r < n; r++) {
            l(t, t.bl_tree[2 * Z[r] + 1], 3);
          }

          z(t, t.dyn_ltree, e - 1), z(t, t.dyn_dtree, a - 1);
        }

        function A(t) {
          var e,
              a = 4093624447;

          for (e = 0; e <= 31; e++, a >>>= 1) {
            if (1 & a && 0 !== t.dyn_ltree[2 * e]) return E;
          }

          if (0 !== t.dyn_ltree[18] || 0 !== t.dyn_ltree[20] || 0 !== t.dyn_ltree[26]) return U;

          for (e = 32; e < L; e++) {
            if (0 !== t.dyn_ltree[2 * e]) return U;
          }

          return E;
        }

        function C(t, e, a, n) {
          l(t, (I << 1) + (n ? 1 : 0), 3), m(t, e, a, !0);
        }

        var S = t("../utils/common"),
            j = 4,
            E = 0,
            U = 1,
            D = 2,
            I = 0,
            O = 1,
            q = 2,
            T = 29,
            L = 256,
            N = L + 1 + T,
            R = 30,
            H = 19,
            F = 2 * N + 1,
            K = 15,
            M = 16,
            P = 7,
            G = 256,
            J = 16,
            Q = 17,
            V = 18,
            W = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0],
            X = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
            Y = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7],
            Z = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
            $ = new Array(2 * (N + 2));
        n($);
        var tt = new Array(2 * R);
        n(tt);
        var et = new Array(512);
        n(et);
        var at = new Array(256);
        n(at);
        var nt = new Array(T);
        n(nt);
        var rt = new Array(R);
        n(rt);
        var it,
            st,
            ht,
            lt = !1;
        a._tr_init = function (t) {
          lt || (c(), lt = !0), t.l_desc = new i(t.dyn_ltree, it), t.d_desc = new i(t.dyn_dtree, st), t.bl_desc = new i(t.bl_tree, ht), t.bi_buf = 0, t.bi_valid = 0, p(t);
        }, a._tr_stored_block = C, a._tr_flush_block = function (t, e, a, n) {
          var r,
              i,
              s = 0;
          t.level > 0 ? (t.strm.data_type === D && (t.strm.data_type = A(t)), y(t, t.l_desc), y(t, t.d_desc), s = x(t), r = t.opt_len + 3 + 7 >>> 3, (i = t.static_len + 3 + 7 >>> 3) <= r && (r = i)) : r = i = a + 5, a + 4 <= r && -1 !== e ? C(t, e, a, n) : t.strategy === j || i === r ? (l(t, (O << 1) + (n ? 1 : 0), 3), v(t, $, tt)) : (l(t, (q << 1) + (n ? 1 : 0), 3), B(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, s + 1), v(t, t.dyn_ltree, t.dyn_dtree)), p(t), n && g(t);
        }, a._tr_tally = function (t, e, a) {
          return t.pending_buf[t.d_buf + 2 * t.last_lit] = e >>> 8 & 255, t.pending_buf[t.d_buf + 2 * t.last_lit + 1] = 255 & e, t.pending_buf[t.l_buf + t.last_lit] = 255 & a, t.last_lit++, 0 === e ? t.dyn_ltree[2 * a]++ : (t.matches++, e--, t.dyn_ltree[2 * (at[a] + L + 1)]++, t.dyn_dtree[2 * s(e)]++), t.last_lit === t.lit_bufsize - 1;
        }, a._tr_align = function (t) {
          l(t, O << 1, 3), o(t, G, $), d(t);
        };
      }, {
        "../utils/common": 1
      }],
      8: [function (t, e, a) {
        "use strict";

        e.exports = function () {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}],
      "/lib/deflate.js": [function (t, e, a) {
        "use strict";

        function n(t) {
          if (!(this instanceof n)) return new n(t);
          this.options = s.assign({
            level: u,
            method: c,
            chunkSize: 16384,
            windowBits: 15,
            memLevel: 8,
            strategy: f,
            to: ""
          }, t || {});
          var e = this.options;
          e.raw && e.windowBits > 0 ? e.windowBits = -e.windowBits : e.gzip && e.windowBits > 0 && e.windowBits < 16 && (e.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new o(), this.strm.avail_out = 0;
          var a = i.deflateInit2(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy);
          if (a !== d) throw new Error(l[a]);

          if (e.header && i.deflateSetHeader(this.strm, e.header), e.dictionary) {
            var r;
            if (r = "string" == typeof e.dictionary ? h.string2buf(e.dictionary) : "[object ArrayBuffer]" === _.call(e.dictionary) ? new Uint8Array(e.dictionary) : e.dictionary, (a = i.deflateSetDictionary(this.strm, r)) !== d) throw new Error(l[a]);
            this._dict_set = !0;
          }
        }

        function r(t, e) {
          var a = new n(e);
          if (a.push(t, !0), a.err) throw a.msg || l[a.err];
          return a.result;
        }

        var i = t("./zlib/deflate"),
            s = t("./utils/common"),
            h = t("./utils/strings"),
            l = t("./zlib/messages"),
            o = t("./zlib/zstream"),
            _ = Object.prototype.toString,
            d = 0,
            u = -1,
            f = 0,
            c = 8;
        n.prototype.push = function (t, e) {
          var a,
              n,
              r = this.strm,
              l = this.options.chunkSize;
          if (this.ended) return !1;
          n = e === ~~e ? e : !0 === e ? 4 : 0, "string" == typeof t ? r.input = h.string2buf(t) : "[object ArrayBuffer]" === _.call(t) ? r.input = new Uint8Array(t) : r.input = t, r.next_in = 0, r.avail_in = r.input.length;

          do {
            if (0 === r.avail_out && (r.output = new s.Buf8(l), r.next_out = 0, r.avail_out = l), 1 !== (a = i.deflate(r, n)) && a !== d) return this.onEnd(a), this.ended = !0, !1;
            0 !== r.avail_out && (0 !== r.avail_in || 4 !== n && 2 !== n) || ("string" === this.options.to ? this.onData(h.buf2binstring(s.shrinkBuf(r.output, r.next_out))) : this.onData(s.shrinkBuf(r.output, r.next_out)));
          } while ((r.avail_in > 0 || 0 === r.avail_out) && 1 !== a);

          return 4 === n ? (a = i.deflateEnd(this.strm), this.onEnd(a), this.ended = !0, a === d) : 2 !== n || (this.onEnd(d), r.avail_out = 0, !0);
        }, n.prototype.onData = function (t) {
          this.chunks.push(t);
        }, n.prototype.onEnd = function (t) {
          t === d && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = s.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg;
        }, a.Deflate = n, a.deflate = r, a.deflateRaw = function (t, e) {
          return e = e || {}, e.raw = !0, r(t, e);
        }, a.gzip = function (t, e) {
          return e = e || {}, e.gzip = !0, r(t, e);
        };
      }, {
        "./utils/common": 1,
        "./utils/strings": 2,
        "./zlib/deflate": 5,
        "./zlib/messages": 6,
        "./zlib/zstream": 8
      }]
    }, {}, [])("/lib/deflate.js");
  });
},22,[],"projects/com.roborock.tanos/Parser/png/deflate_mini.js");
var parse = __r(0).parse;
